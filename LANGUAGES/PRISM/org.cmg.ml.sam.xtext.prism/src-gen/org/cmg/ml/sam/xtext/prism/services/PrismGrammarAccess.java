/*
 * generated by Xtext
 */
package org.cmg.ml.sam.xtext.prism.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class PrismGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Model");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeModelTypeParserRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsElementParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		//Model:
		//	type=ModelType
		//	elements+=Element*;
		@Override public ParserRule getRule() { return rule; }

		//type=ModelType elements+=Element*
		public Group getGroup() { return cGroup; }

		//type=ModelType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ModelType
		public RuleCall getTypeModelTypeParserRuleCall_0_0() { return cTypeModelTypeParserRuleCall_0_0; }

		//elements+=Element*
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//Element
		public RuleCall getElementsElementParserRuleCall_1_0() { return cElementsElementParserRuleCall_1_0; }
	}

	public class ElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Element");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cModuleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGlobalParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRewardParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cInitPredicateParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cFormulaParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cLabelParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cPrismSystemParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cPathFormulaDeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cStateFormulaDeclarationParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//Element:
		//	Module
		//	| Global
		//	| Constant
		//	| Reward
		//	| InitPredicate
		//	| Formula
		//	| Label
		//	| PrismSystem
		//	| PathFormulaDeclaration
		//	| StateFormulaDeclaration;
		@Override public ParserRule getRule() { return rule; }

		//Module | Global | Constant | Reward | InitPredicate | Formula | Label | PrismSystem | PathFormulaDeclaration |
		//StateFormulaDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//Module
		public RuleCall getModuleParserRuleCall_0() { return cModuleParserRuleCall_0; }

		//Global
		public RuleCall getGlobalParserRuleCall_1() { return cGlobalParserRuleCall_1; }

		//Constant
		public RuleCall getConstantParserRuleCall_2() { return cConstantParserRuleCall_2; }

		//Reward
		public RuleCall getRewardParserRuleCall_3() { return cRewardParserRuleCall_3; }

		//InitPredicate
		public RuleCall getInitPredicateParserRuleCall_4() { return cInitPredicateParserRuleCall_4; }

		//Formula
		public RuleCall getFormulaParserRuleCall_5() { return cFormulaParserRuleCall_5; }

		//Label
		public RuleCall getLabelParserRuleCall_6() { return cLabelParserRuleCall_6; }

		//PrismSystem
		public RuleCall getPrismSystemParserRuleCall_7() { return cPrismSystemParserRuleCall_7; }

		//PathFormulaDeclaration
		public RuleCall getPathFormulaDeclarationParserRuleCall_8() { return cPathFormulaDeclarationParserRuleCall_8; }

		//StateFormulaDeclaration
		public RuleCall getStateFormulaDeclarationParserRuleCall_9() { return cStateFormulaDeclarationParserRuleCall_9; }
	}

	public class PathFormulaDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.PathFormulaDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPathformulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFormulaAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFormulaPathFormulaParserRuleCall_3_0 = (RuleCall)cFormulaAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PathFormulaDeclaration:
		//	'pathformula' name=ID '=' formula=PathFormula ';';
		@Override public ParserRule getRule() { return rule; }

		//'pathformula' name=ID '=' formula=PathFormula ';'
		public Group getGroup() { return cGroup; }

		//'pathformula'
		public Keyword getPathformulaKeyword_0() { return cPathformulaKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//formula=PathFormula
		public Assignment getFormulaAssignment_3() { return cFormulaAssignment_3; }

		//PathFormula
		public RuleCall getFormulaPathFormulaParserRuleCall_3_0() { return cFormulaPathFormulaParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class StateFormulaDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.StateFormulaDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStateformulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cFormulaAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFormulaStateFormulaParserRuleCall_3_0 = (RuleCall)cFormulaAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//StateFormulaDeclaration:
		//	'stateformula' name=ID '=' formula=StateFormula ';';
		@Override public ParserRule getRule() { return rule; }

		//'stateformula' name=ID '=' formula=StateFormula ';'
		public Group getGroup() { return cGroup; }

		//'stateformula'
		public Keyword getStateformulaKeyword_0() { return cStateformulaKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//formula=StateFormula
		public Assignment getFormulaAssignment_3() { return cFormulaAssignment_3; }

		//StateFormula
		public RuleCall getFormulaStateFormulaParserRuleCall_3_0() { return cFormulaStateFormulaParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class PathFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.PathFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNextFormulaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUntilFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PathFormula:
		//	NextFormula | UntilFormula;
		@Override public ParserRule getRule() { return rule; }

		//NextFormula | UntilFormula
		public Alternatives getAlternatives() { return cAlternatives; }

		//NextFormula
		public RuleCall getNextFormulaParserRuleCall_0() { return cNextFormulaParserRuleCall_0; }

		//UntilFormula
		public RuleCall getUntilFormulaParserRuleCall_1() { return cUntilFormulaParserRuleCall_1; }
	}

	public class UntilFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.UntilFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftStateFormulaParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Keyword cUKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBoundAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBoundBoundParserRuleCall_2_0 = (RuleCall)cBoundAssignment_2.eContents().get(0);
		private final Assignment cRightAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRightStateFormulaParserRuleCall_3_0 = (RuleCall)cRightAssignment_3.eContents().get(0);
		
		//UntilFormula:
		//	left=StateFormula '\\U' bound=Bound? right=StateFormula;
		@Override public ParserRule getRule() { return rule; }

		//left=StateFormula '\\U' bound=Bound? right=StateFormula
		public Group getGroup() { return cGroup; }

		//left=StateFormula
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }

		//StateFormula
		public RuleCall getLeftStateFormulaParserRuleCall_0_0() { return cLeftStateFormulaParserRuleCall_0_0; }

		//'\\U'
		public Keyword getUKeyword_1() { return cUKeyword_1; }

		//bound=Bound?
		public Assignment getBoundAssignment_2() { return cBoundAssignment_2; }

		//Bound
		public RuleCall getBoundBoundParserRuleCall_2_0() { return cBoundBoundParserRuleCall_2_0; }

		//right=StateFormula
		public Assignment getRightAssignment_3() { return cRightAssignment_3; }

		//StateFormula
		public RuleCall getRightStateFormulaParserRuleCall_3_0() { return cRightStateFormulaParserRuleCall_3_0; }
	}

	public class BoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Bound");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRelopAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRelopRelationsEnumRuleCall_0_0 = (RuleCall)cRelopAssignment_0.eContents().get(0);
		private final Assignment cLimitAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLimitINTTerminalRuleCall_1_0 = (RuleCall)cLimitAssignment_1.eContents().get(0);
		
		//Bound:
		//	relop=Relations limit=INT;
		@Override public ParserRule getRule() { return rule; }

		//relop=Relations limit=INT
		public Group getGroup() { return cGroup; }

		//relop=Relations
		public Assignment getRelopAssignment_0() { return cRelopAssignment_0; }

		//Relations
		public RuleCall getRelopRelationsEnumRuleCall_0_0() { return cRelopRelationsEnumRuleCall_0_0; }

		//limit=INT
		public Assignment getLimitAssignment_1() { return cLimitAssignment_1; }

		//INT
		public RuleCall getLimitINTTerminalRuleCall_1_0() { return cLimitINTTerminalRuleCall_1_0; }
	}

	public class NextFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.NextFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cXKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cArgAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgStateFormulaParserRuleCall_1_0 = (RuleCall)cArgAssignment_1.eContents().get(0);
		
		//NextFormula:
		//	'\\X' arg=StateFormula;
		@Override public ParserRule getRule() { return rule; }

		//'\\X' arg=StateFormula
		public Group getGroup() { return cGroup; }

		//'\\X'
		public Keyword getXKeyword_0() { return cXKeyword_0; }

		//arg=StateFormula
		public Assignment getArgAssignment_1() { return cArgAssignment_1; }

		//StateFormula
		public RuleCall getArgStateFormulaParserRuleCall_1_0() { return cArgStateFormulaParserRuleCall_1_0; }
	}

	public class StateFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.StateFormula");
		private final RuleCall cStateOrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StateFormula:
		//	StateOr;
		@Override public ParserRule getRule() { return rule; }

		//StateOr
		public RuleCall getStateOrParserRuleCall() { return cStateOrParserRuleCall; }
	}

	public class StateOrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.StateOr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cStateAndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cStateOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightStateOrParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//StateOr StateFormula:
		//	StateAnd ({StateOr.left=current} '|' right=StateOr)?
		@Override public ParserRule getRule() { return rule; }

		//StateAnd ({StateOr.left=current} '|' right=StateOr)?
		public Group getGroup() { return cGroup; }

		//StateAnd
		public RuleCall getStateAndParserRuleCall_0() { return cStateAndParserRuleCall_0; }

		//({StateOr.left=current} '|' right=StateOr)?
		public Group getGroup_1() { return cGroup_1; }

		//{StateOr.left=current}
		public Action getStateOrLeftAction_1_0() { return cStateOrLeftAction_1_0; }

		//'|'
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=StateOr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//StateOr
		public RuleCall getRightStateOrParserRuleCall_1_2_0() { return cRightStateOrParserRuleCall_1_2_0; }
	}

	public class StateAndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.StateAnd");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseStateFormulaParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cStateAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightStateAndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//StateAnd StateFormula:
		//	BaseStateFormula ({StateAnd.left=current} '&' right=StateAnd)?
		@Override public ParserRule getRule() { return rule; }

		//BaseStateFormula ({StateAnd.left=current} '&' right=StateAnd)?
		public Group getGroup() { return cGroup; }

		//BaseStateFormula
		public RuleCall getBaseStateFormulaParserRuleCall_0() { return cBaseStateFormulaParserRuleCall_0; }

		//({StateAnd.left=current} '&' right=StateAnd)?
		public Group getGroup_1() { return cGroup_1; }

		//{StateAnd.left=current}
		public Action getStateAndLeftAction_1_0() { return cStateAndLeftAction_1_0; }

		//'&'
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//right=StateAnd
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//StateAnd
		public RuleCall getRightStateAndParserRuleCall_1_2_0() { return cRightStateAndParserRuleCall_1_2_0; }
	}

	public class BaseStateFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.BaseStateFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomicStateFormulaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNegationFormulaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final RuleCall cStateFormulaParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final RuleCall cProbabilityFormulaParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//BaseStateFormula StateFormula:
		//	AtomicStateFormula
		//	| NegationFormula
		//	| '(' StateFormula ')'
		//	| ProbabilityFormula
		@Override public ParserRule getRule() { return rule; }

		//AtomicStateFormula | NegationFormula | '(' StateFormula ')' | ProbabilityFormula
		public Alternatives getAlternatives() { return cAlternatives; }

		//AtomicStateFormula
		public RuleCall getAtomicStateFormulaParserRuleCall_0() { return cAtomicStateFormulaParserRuleCall_0; }

		//NegationFormula
		public RuleCall getNegationFormulaParserRuleCall_1() { return cNegationFormulaParserRuleCall_1; }

		//'(' StateFormula ')'
		public Group getGroup_2() { return cGroup_2; }

		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }

		//StateFormula
		public RuleCall getStateFormulaParserRuleCall_2_1() { return cStateFormulaParserRuleCall_2_1; }

		//')'
		public Keyword getRightParenthesisKeyword_2_2() { return cRightParenthesisKeyword_2_2; }

		//ProbabilityFormula
		public RuleCall getProbabilityFormulaParserRuleCall_3() { return cProbabilityFormulaParserRuleCall_3; }
	}

	public class ProbabilityFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ProbabilityFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRelationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRelationRelationsEnumRuleCall_1_0 = (RuleCall)cRelationAssignment_1.eContents().get(0);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueNumericalValueParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cPathAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cPathPathFormulaParserRuleCall_4_0 = (RuleCall)cPathAssignment_4.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ProbabilityFormula:
		//	'\\P' relation=Relations value=NumericalValue '[' path=PathFormula ']';
		@Override public ParserRule getRule() { return rule; }

		//'\\P' relation=Relations value=NumericalValue '[' path=PathFormula ']'
		public Group getGroup() { return cGroup; }

		//'\\P'
		public Keyword getPKeyword_0() { return cPKeyword_0; }

		//relation=Relations
		public Assignment getRelationAssignment_1() { return cRelationAssignment_1; }

		//Relations
		public RuleCall getRelationRelationsEnumRuleCall_1_0() { return cRelationRelationsEnumRuleCall_1_0; }

		//value=NumericalValue
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//NumericalValue
		public RuleCall getValueNumericalValueParserRuleCall_2_0() { return cValueNumericalValueParserRuleCall_2_0; }

		//'['
		public Keyword getLeftSquareBracketKeyword_3() { return cLeftSquareBracketKeyword_3; }

		//path=PathFormula
		public Assignment getPathAssignment_4() { return cPathAssignment_4; }

		//PathFormula
		public RuleCall getPathPathFormulaParserRuleCall_4_0() { return cPathPathFormulaParserRuleCall_4_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class NegationFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.NegationFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExclamationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cArgumentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cArgumentBaseStateFormulaParserRuleCall_1_0 = (RuleCall)cArgumentAssignment_1.eContents().get(0);
		
		//NegationFormula:
		//	'!' argument=BaseStateFormula;
		@Override public ParserRule getRule() { return rule; }

		//'!' argument=BaseStateFormula
		public Group getGroup() { return cGroup; }

		//'!'
		public Keyword getExclamationMarkKeyword_0() { return cExclamationMarkKeyword_0; }

		//argument=BaseStateFormula
		public Assignment getArgumentAssignment_1() { return cArgumentAssignment_1; }

		//BaseStateFormula
		public RuleCall getArgumentBaseStateFormulaParserRuleCall_1_0() { return cArgumentBaseStateFormulaParserRuleCall_1_0; }
	}

	public class AtomicStateFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.AtomicStateFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//AtomicStateFormula:
		//	'{' exp=Expression '}';
		@Override public ParserRule getRule() { return rule; }

		//'{' exp=Expression '}'
		public Group getGroup() { return cGroup; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//exp=Expression
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }

		//Expression
		public RuleCall getExpExpressionParserRuleCall_1_0() { return cExpExpressionParserRuleCall_1_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class PrismSystemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.PrismSystem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSystemKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cAlphabetisedParallelCompositionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cEndsystemKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//PrismSystem:
		//	'system'
		//	AlphabetisedParallelComposition
		//	'endsystem';
		@Override public ParserRule getRule() { return rule; }

		//'system' AlphabetisedParallelComposition 'endsystem'
		public Group getGroup() { return cGroup; }

		//'system'
		public Keyword getSystemKeyword_0() { return cSystemKeyword_0; }

		//AlphabetisedParallelComposition
		public RuleCall getAlphabetisedParallelCompositionParserRuleCall_1() { return cAlphabetisedParallelCompositionParserRuleCall_1; }

		//'endsystem'
		public Keyword getEndsystemKeyword_2() { return cEndsystemKeyword_2; }
	}

	public class AlphabetisedParallelCompositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.AlphabetisedParallelComposition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAsynchronousParallelCompositionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAlphabetisedParallelCompositionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAlphabetisedParallelCompositionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AlphabetisedParallelComposition PrismSystem:
		//	AsynchronousParallelComposition ({AlphabetisedParallelComposition.left=current} '||'
		//	right=AlphabetisedParallelComposition)?
		@Override public ParserRule getRule() { return rule; }

		//AsynchronousParallelComposition ({AlphabetisedParallelComposition.left=current} '||'
		//right=AlphabetisedParallelComposition)?
		public Group getGroup() { return cGroup; }

		//AsynchronousParallelComposition
		public RuleCall getAsynchronousParallelCompositionParserRuleCall_0() { return cAsynchronousParallelCompositionParserRuleCall_0; }

		//({AlphabetisedParallelComposition.left=current} '||' right=AlphabetisedParallelComposition)?
		public Group getGroup_1() { return cGroup_1; }

		//{AlphabetisedParallelComposition.left=current}
		public Action getAlphabetisedParallelCompositionLeftAction_1_0() { return cAlphabetisedParallelCompositionLeftAction_1_0; }

		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineKeyword_1_1; }

		//right=AlphabetisedParallelComposition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AlphabetisedParallelComposition
		public RuleCall getRightAlphabetisedParallelCompositionParserRuleCall_1_2_0() { return cRightAlphabetisedParallelCompositionParserRuleCall_1_2_0; }
	}

	public class AsynchronousParallelCompositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.AsynchronousParallelComposition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRestrictedParallelCompositionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAsynchronousParallelCompositionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAsynchronousParallelCompositionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AsynchronousParallelComposition PrismSystem:
		//	RestrictedParallelComposition ({AsynchronousParallelComposition.left=current} '|||'
		//	right=AsynchronousParallelComposition)?
		@Override public ParserRule getRule() { return rule; }

		//RestrictedParallelComposition ({AsynchronousParallelComposition.left=current} '|||'
		//right=AsynchronousParallelComposition)?
		public Group getGroup() { return cGroup; }

		//RestrictedParallelComposition
		public RuleCall getRestrictedParallelCompositionParserRuleCall_0() { return cRestrictedParallelCompositionParserRuleCall_0; }

		//({AsynchronousParallelComposition.left=current} '|||' right=AsynchronousParallelComposition)?
		public Group getGroup_1() { return cGroup_1; }

		//{AsynchronousParallelComposition.left=current}
		public Action getAsynchronousParallelCompositionLeftAction_1_0() { return cAsynchronousParallelCompositionLeftAction_1_0; }

		//'|||'
		public Keyword getVerticalLineVerticalLineVerticalLineKeyword_1_1() { return cVerticalLineVerticalLineVerticalLineKeyword_1_1; }

		//right=AsynchronousParallelComposition
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AsynchronousParallelComposition
		public RuleCall getRightAsynchronousParallelCompositionParserRuleCall_1_2_0() { return cRightAsynchronousParallelCompositionParserRuleCall_1_2_0; }
	}

	public class RestrictedParallelCompositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.RestrictedParallelComposition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cHidingParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRestrictedParallelCompositionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cActionsAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cActionsIDTerminalRuleCall_1_2_0_0 = (RuleCall)cActionsAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cActionsAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cActionsIDTerminalRuleCall_1_2_1_1_0 = (RuleCall)cActionsAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cVerticalLineRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cRightAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cRightRestrictedParallelCompositionParserRuleCall_1_4_0 = (RuleCall)cRightAssignment_1_4.eContents().get(0);
		
		//RestrictedParallelComposition PrismSystem:
		//	Hiding ({RestrictedParallelComposition.left=current} '|[' (actions+=ID (',' actions+=ID)*)? '|]'
		//	right=RestrictedParallelComposition)?
		@Override public ParserRule getRule() { return rule; }

		//Hiding ({RestrictedParallelComposition.left=current} '|[' (actions+=ID (',' actions+=ID)*)? '|]'
		//right=RestrictedParallelComposition)?
		public Group getGroup() { return cGroup; }

		//Hiding
		public RuleCall getHidingParserRuleCall_0() { return cHidingParserRuleCall_0; }

		//({RestrictedParallelComposition.left=current} '|[' (actions+=ID (',' actions+=ID)*)? '|]'
		//right=RestrictedParallelComposition)?
		public Group getGroup_1() { return cGroup_1; }

		//{RestrictedParallelComposition.left=current}
		public Action getRestrictedParallelCompositionLeftAction_1_0() { return cRestrictedParallelCompositionLeftAction_1_0; }

		//'|['
		public Keyword getVerticalLineLeftSquareBracketKeyword_1_1() { return cVerticalLineLeftSquareBracketKeyword_1_1; }

		//(actions+=ID (',' actions+=ID)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//actions+=ID
		public Assignment getActionsAssignment_1_2_0() { return cActionsAssignment_1_2_0; }

		//ID
		public RuleCall getActionsIDTerminalRuleCall_1_2_0_0() { return cActionsIDTerminalRuleCall_1_2_0_0; }

		//(',' actions+=ID)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//','
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//actions+=ID
		public Assignment getActionsAssignment_1_2_1_1() { return cActionsAssignment_1_2_1_1; }

		//ID
		public RuleCall getActionsIDTerminalRuleCall_1_2_1_1_0() { return cActionsIDTerminalRuleCall_1_2_1_1_0; }

		//'|]'
		public Keyword getVerticalLineRightSquareBracketKeyword_1_3() { return cVerticalLineRightSquareBracketKeyword_1_3; }

		//right=RestrictedParallelComposition
		public Assignment getRightAssignment_1_4() { return cRightAssignment_1_4; }

		//RestrictedParallelComposition
		public RuleCall getRightRestrictedParallelCompositionParserRuleCall_1_4_0() { return cRightRestrictedParallelCompositionParserRuleCall_1_4_0; }
	}

	public class HidingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Hiding");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cRenamingParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cHidingArgumentAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Group cGroup_1_3 = (Group)cGroup_1.eContents().get(3);
		private final Assignment cActionsAssignment_1_3_0 = (Assignment)cGroup_1_3.eContents().get(0);
		private final RuleCall cActionsIDTerminalRuleCall_1_3_0_0 = (RuleCall)cActionsAssignment_1_3_0.eContents().get(0);
		private final Group cGroup_1_3_1 = (Group)cGroup_1_3.eContents().get(1);
		private final Keyword cCommaKeyword_1_3_1_0 = (Keyword)cGroup_1_3_1.eContents().get(0);
		private final Assignment cActionsAssignment_1_3_1_1 = (Assignment)cGroup_1_3_1.eContents().get(1);
		private final RuleCall cActionsIDTerminalRuleCall_1_3_1_1_0 = (RuleCall)cActionsAssignment_1_3_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//Hiding PrismSystem:
		//	Renaming ({Hiding.argument=current} '/' '{' (actions+=ID (',' actions+=ID)*)? '}')?
		@Override public ParserRule getRule() { return rule; }

		//Renaming ({Hiding.argument=current} '/' '{' (actions+=ID (',' actions+=ID)*)? '}')?
		public Group getGroup() { return cGroup; }

		//Renaming
		public RuleCall getRenamingParserRuleCall_0() { return cRenamingParserRuleCall_0; }

		//({Hiding.argument=current} '/' '{' (actions+=ID (',' actions+=ID)*)? '}')?
		public Group getGroup_1() { return cGroup_1; }

		//{Hiding.argument=current}
		public Action getHidingArgumentAction_1_0() { return cHidingArgumentAction_1_0; }

		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_2() { return cLeftCurlyBracketKeyword_1_2; }

		//(actions+=ID (',' actions+=ID)*)?
		public Group getGroup_1_3() { return cGroup_1_3; }

		//actions+=ID
		public Assignment getActionsAssignment_1_3_0() { return cActionsAssignment_1_3_0; }

		//ID
		public RuleCall getActionsIDTerminalRuleCall_1_3_0_0() { return cActionsIDTerminalRuleCall_1_3_0_0; }

		//(',' actions+=ID)*
		public Group getGroup_1_3_1() { return cGroup_1_3_1; }

		//','
		public Keyword getCommaKeyword_1_3_1_0() { return cCommaKeyword_1_3_1_0; }

		//actions+=ID
		public Assignment getActionsAssignment_1_3_1_1() { return cActionsAssignment_1_3_1_1; }

		//ID
		public RuleCall getActionsIDTerminalRuleCall_1_3_1_1_0() { return cActionsIDTerminalRuleCall_1_3_1_1_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_1_4() { return cRightCurlyBracketKeyword_1_4; }
	}

	public class RenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Renaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseModuleParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRenamingArgumentAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Assignment cRenamingAssignment_1_2_0 = (Assignment)cGroup_1_2.eContents().get(0);
		private final RuleCall cRenamingActionRenamingParserRuleCall_1_2_0_0 = (RuleCall)cRenamingAssignment_1_2_0.eContents().get(0);
		private final Group cGroup_1_2_1 = (Group)cGroup_1_2.eContents().get(1);
		private final Keyword cCommaKeyword_1_2_1_0 = (Keyword)cGroup_1_2_1.eContents().get(0);
		private final Assignment cRenamingAssignment_1_2_1_1 = (Assignment)cGroup_1_2_1.eContents().get(1);
		private final RuleCall cRenamingActionRenamingParserRuleCall_1_2_1_1_0 = (RuleCall)cRenamingAssignment_1_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Renaming PrismSystem:
		//	BaseModule ({Renaming.argument=current} '{' (renaming+=ActionRenaming (',' renaming+=ActionRenaming)*)? '}')?
		@Override public ParserRule getRule() { return rule; }

		//BaseModule ({Renaming.argument=current} '{' (renaming+=ActionRenaming (',' renaming+=ActionRenaming)*)? '}')?
		public Group getGroup() { return cGroup; }

		//BaseModule
		public RuleCall getBaseModuleParserRuleCall_0() { return cBaseModuleParserRuleCall_0; }

		//({Renaming.argument=current} '{' (renaming+=ActionRenaming (',' renaming+=ActionRenaming)*)? '}')?
		public Group getGroup_1() { return cGroup_1; }

		//{Renaming.argument=current}
		public Action getRenamingArgumentAction_1_0() { return cRenamingArgumentAction_1_0; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_1() { return cLeftCurlyBracketKeyword_1_1; }

		//(renaming+=ActionRenaming (',' renaming+=ActionRenaming)*)?
		public Group getGroup_1_2() { return cGroup_1_2; }

		//renaming+=ActionRenaming
		public Assignment getRenamingAssignment_1_2_0() { return cRenamingAssignment_1_2_0; }

		//ActionRenaming
		public RuleCall getRenamingActionRenamingParserRuleCall_1_2_0_0() { return cRenamingActionRenamingParserRuleCall_1_2_0_0; }

		//(',' renaming+=ActionRenaming)*
		public Group getGroup_1_2_1() { return cGroup_1_2_1; }

		//','
		public Keyword getCommaKeyword_1_2_1_0() { return cCommaKeyword_1_2_1_0; }

		//renaming+=ActionRenaming
		public Assignment getRenamingAssignment_1_2_1_1() { return cRenamingAssignment_1_2_1_1; }

		//ActionRenaming
		public RuleCall getRenamingActionRenamingParserRuleCall_1_2_1_1_0() { return cRenamingActionRenamingParserRuleCall_1_2_1_1_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_1_3() { return cRightCurlyBracketKeyword_1_3; }
	}

	public class ActionRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ActionRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSourceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSourceIDTerminalRuleCall_0_0 = (RuleCall)cSourceAssignment_0.eContents().get(0);
		private final Keyword cLessThanSignHyphenMinusKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTargetIDTerminalRuleCall_2_0 = (RuleCall)cTargetAssignment_2.eContents().get(0);
		
		//ActionRenaming:
		//	source=ID '<-' target=ID;
		@Override public ParserRule getRule() { return rule; }

		//source=ID '<-' target=ID
		public Group getGroup() { return cGroup; }

		//source=ID
		public Assignment getSourceAssignment_0() { return cSourceAssignment_0; }

		//ID
		public RuleCall getSourceIDTerminalRuleCall_0_0() { return cSourceIDTerminalRuleCall_0_0; }

		//'<-'
		public Keyword getLessThanSignHyphenMinusKeyword_1() { return cLessThanSignHyphenMinusKeyword_1; }

		//target=ID
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }

		//ID
		public RuleCall getTargetIDTerminalRuleCall_2_0() { return cTargetIDTerminalRuleCall_2_0; }
	}

	public class BaseModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.BaseModule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cModuleReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cAlphabetisedParallelCompositionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BaseModule PrismSystem:
		//	ModuleReference
		//	| '(' AlphabetisedParallelComposition ')'
		@Override public ParserRule getRule() { return rule; }

		//ModuleReference | '(' AlphabetisedParallelComposition ')'
		public Alternatives getAlternatives() { return cAlternatives; }

		//ModuleReference
		public RuleCall getModuleReferenceParserRuleCall_0() { return cModuleReferenceParserRuleCall_0; }

		//'(' AlphabetisedParallelComposition ')'
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//AlphabetisedParallelComposition
		public RuleCall getAlphabetisedParallelCompositionParserRuleCall_1_1() { return cAlphabetisedParallelCompositionParserRuleCall_1_1; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class ModuleReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ModuleReference");
		private final Assignment cModuleAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cModuleModuleCrossReference_0 = (CrossReference)cModuleAssignment.eContents().get(0);
		private final RuleCall cModuleModuleIDTerminalRuleCall_0_1 = (RuleCall)cModuleModuleCrossReference_0.eContents().get(1);
		
		//ModuleReference:
		//	module=[Module];
		@Override public ParserRule getRule() { return rule; }

		//module=[Module]
		public Assignment getModuleAssignment() { return cModuleAssignment; }

		//[Module]
		public CrossReference getModuleModuleCrossReference_0() { return cModuleModuleCrossReference_0; }

		//ID
		public RuleCall getModuleModuleIDTerminalRuleCall_0_1() { return cModuleModuleIDTerminalRuleCall_0_1; }
	}

	public class GlobalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Global");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGlobalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cVariableParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Global Variable:
		//	'global' Variable
		@Override public ParserRule getRule() { return rule; }

		//'global' Variable
		public Group getGroup() { return cGroup; }

		//'global'
		public Keyword getGlobalKeyword_0() { return cGlobalKeyword_0; }

		//Variable
		public RuleCall getVariableParserRuleCall_1() { return cVariableParserRuleCall_1; }
	}

	public class LabelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Label");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLabelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Label:
		//	'label' name=STRING '=' expression=Expression ';';
		@Override public ParserRule getRule() { return rule; }

		//'label' name=STRING '=' expression=Expression ';'
		public Group getGroup() { return cGroup; }

		//'label'
		public Keyword getLabelKeyword_0() { return cLabelKeyword_0; }

		//name=STRING
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//STRING
		public RuleCall getNameSTRINGTerminalRuleCall_1_0() { return cNameSTRINGTerminalRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Formula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFormulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Formula:
		//	'formula' name=ID '=' expression=Expression ';';
		@Override public ParserRule getRule() { return rule; }

		//'formula' name=ID '=' expression=Expression ';'
		public Group getGroup() { return cGroup; }

		//'formula'
		public Keyword getFormulaKeyword_0() { return cFormulaKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class InitPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.InitPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPredicateAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredicateExpressionParserRuleCall_1_0 = (RuleCall)cPredicateAssignment_1.eContents().get(0);
		private final Keyword cEndinitKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//InitPredicate:
		//	'init'
		//	predicate=Expression
		//	'endinit';
		@Override public ParserRule getRule() { return rule; }

		//'init' predicate=Expression 'endinit'
		public Group getGroup() { return cGroup; }

		//'init'
		public Keyword getInitKeyword_0() { return cInitKeyword_0; }

		//predicate=Expression
		public Assignment getPredicateAssignment_1() { return cPredicateAssignment_1; }

		//Expression
		public RuleCall getPredicateExpressionParserRuleCall_1_0() { return cPredicateExpressionParserRuleCall_1_0; }

		//'endinit'
		public Keyword getEndinitKeyword_2() { return cEndinitKeyword_2; }
	}

	public class RewardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Reward");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRewardAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRewardsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLabelAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLabelSTRINGTerminalRuleCall_2_0 = (RuleCall)cLabelAssignment_2.eContents().get(0);
		private final Assignment cCasesAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCasesRewardCaseParserRuleCall_3_0 = (RuleCall)cCasesAssignment_3.eContents().get(0);
		private final Keyword cEndrewardsKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Reward:
		//	{Reward}
		//	'rewards' label=STRING? cases+=RewardCase* 'endrewards';
		@Override public ParserRule getRule() { return rule; }

		//{Reward} 'rewards' label=STRING? cases+=RewardCase* 'endrewards'
		public Group getGroup() { return cGroup; }

		//{Reward}
		public Action getRewardAction_0() { return cRewardAction_0; }

		//'rewards'
		public Keyword getRewardsKeyword_1() { return cRewardsKeyword_1; }

		//label=STRING?
		public Assignment getLabelAssignment_2() { return cLabelAssignment_2; }

		//STRING
		public RuleCall getLabelSTRINGTerminalRuleCall_2_0() { return cLabelSTRINGTerminalRuleCall_2_0; }

		//cases+=RewardCase*
		public Assignment getCasesAssignment_3() { return cCasesAssignment_3; }

		//RewardCase
		public RuleCall getCasesRewardCaseParserRuleCall_3_0() { return cCasesRewardCaseParserRuleCall_3_0; }

		//'endrewards'
		public Keyword getEndrewardsKeyword_4() { return cEndrewardsKeyword_4; }
	}

	public class RewardCaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.RewardCase");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cActionAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cActionIDTerminalRuleCall_0_1_0 = (RuleCall)cActionAssignment_0_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Assignment cGuardAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cGuardExpressionParserRuleCall_1_0 = (RuleCall)cGuardAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//RewardCase:
		//	('[' action=ID ']')? guard=Expression ':' value=Expression ';';
		@Override public ParserRule getRule() { return rule; }

		//('[' action=ID ']')? guard=Expression ':' value=Expression ';'
		public Group getGroup() { return cGroup; }

		//('[' action=ID ']')?
		public Group getGroup_0() { return cGroup_0; }

		//'['
		public Keyword getLeftSquareBracketKeyword_0_0() { return cLeftSquareBracketKeyword_0_0; }

		//action=ID
		public Assignment getActionAssignment_0_1() { return cActionAssignment_0_1; }

		//ID
		public RuleCall getActionIDTerminalRuleCall_0_1_0() { return cActionIDTerminalRuleCall_0_1_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_0_2() { return cRightSquareBracketKeyword_0_2; }

		//guard=Expression
		public Assignment getGuardAssignment_1() { return cGuardAssignment_1; }

		//Expression
		public RuleCall getGuardExpressionParserRuleCall_1_0() { return cGuardExpressionParserRuleCall_1_0; }

		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }

		//value=Expression
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeConstantTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExpAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExpExpressionParserRuleCall_4_0 = (RuleCall)cExpAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Constant:
		//	'const' type=ConstantType name=ID '=' exp=Expression ';';
		@Override public ParserRule getRule() { return rule; }

		//'const' type=ConstantType name=ID '=' exp=Expression ';'
		public Group getGroup() { return cGroup; }

		//'const'
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }

		//type=ConstantType
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//ConstantType
		public RuleCall getTypeConstantTypeEnumRuleCall_1_0() { return cTypeConstantTypeEnumRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//'='
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//exp=Expression
		public Assignment getExpAssignment_4() { return cExpAssignment_4; }

		//Expression
		public RuleCall getExpExpressionParserRuleCall_4_0() { return cExpExpressionParserRuleCall_4_0; }

		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}

	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cBodyAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBodyModuleBodyParserRuleCall_2_0 = (RuleCall)cBodyAssignment_2.eContents().get(0);
		private final Keyword cEndmoduleKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Module:
		//	'module' name=ID body=ModuleBody 'endmodule';
		@Override public ParserRule getRule() { return rule; }

		//'module' name=ID body=ModuleBody 'endmodule'
		public Group getGroup() { return cGroup; }

		//'module'
		public Keyword getModuleKeyword_0() { return cModuleKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//body=ModuleBody
		public Assignment getBodyAssignment_2() { return cBodyAssignment_2; }

		//ModuleBody
		public RuleCall getBodyModuleBodyParserRuleCall_2_0() { return cBodyModuleBodyParserRuleCall_2_0; }

		//'endmodule'
		public Keyword getEndmoduleKeyword_3() { return cEndmoduleKeyword_3; }
	}

	public class ModuleBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ModuleBody");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cModuleBodyDeclarationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cVariableRenamingParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ModuleBody:
		//	ModuleBodyDeclaration | VariableRenaming;
		@Override public ParserRule getRule() { return rule; }

		//ModuleBodyDeclaration | VariableRenaming
		public Alternatives getAlternatives() { return cAlternatives; }

		//ModuleBodyDeclaration
		public RuleCall getModuleBodyDeclarationParserRuleCall_0() { return cModuleBodyDeclarationParserRuleCall_0; }

		//VariableRenaming
		public RuleCall getVariableRenamingParserRuleCall_1() { return cVariableRenamingParserRuleCall_1; }
	}

	public class VariableRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.VariableRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEqualsSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cModuleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cModuleModuleCrossReference_1_0 = (CrossReference)cModuleAssignment_1.eContents().get(0);
		private final RuleCall cModuleModuleIDTerminalRuleCall_1_0_1 = (RuleCall)cModuleModuleCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cRenamingAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cRenamingSymbolRenamingParserRuleCall_3_0 = (RuleCall)cRenamingAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRenamingAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRenamingSymbolRenamingParserRuleCall_4_1_0 = (RuleCall)cRenamingAssignment_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//VariableRenaming:
		//	'=' module=[Module] '[' renaming+=SymbolRenaming (',' renaming+=SymbolRenaming)* ']';
		@Override public ParserRule getRule() { return rule; }

		//'=' module=[Module] '[' renaming+=SymbolRenaming (',' renaming+=SymbolRenaming)* ']'
		public Group getGroup() { return cGroup; }

		//'='
		public Keyword getEqualsSignKeyword_0() { return cEqualsSignKeyword_0; }

		//module=[Module]
		public Assignment getModuleAssignment_1() { return cModuleAssignment_1; }

		//[Module]
		public CrossReference getModuleModuleCrossReference_1_0() { return cModuleModuleCrossReference_1_0; }

		//ID
		public RuleCall getModuleModuleIDTerminalRuleCall_1_0_1() { return cModuleModuleIDTerminalRuleCall_1_0_1; }

		//'['
		public Keyword getLeftSquareBracketKeyword_2() { return cLeftSquareBracketKeyword_2; }

		//renaming+=SymbolRenaming
		public Assignment getRenamingAssignment_3() { return cRenamingAssignment_3; }

		//SymbolRenaming
		public RuleCall getRenamingSymbolRenamingParserRuleCall_3_0() { return cRenamingSymbolRenamingParserRuleCall_3_0; }

		//(',' renaming+=SymbolRenaming)*
		public Group getGroup_4() { return cGroup_4; }

		//','
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }

		//renaming+=SymbolRenaming
		public Assignment getRenamingAssignment_4_1() { return cRenamingAssignment_4_1; }

		//SymbolRenaming
		public RuleCall getRenamingSymbolRenamingParserRuleCall_4_1_0() { return cRenamingSymbolRenamingParserRuleCall_4_1_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_5() { return cRightSquareBracketKeyword_5; }
	}

	public class SymbolRenamingElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.SymbolRenaming");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSourceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSourceIDTerminalRuleCall_0_0 = (RuleCall)cSourceAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTargetAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTargetIDTerminalRuleCall_2_0 = (RuleCall)cTargetAssignment_2.eContents().get(0);
		
		//SymbolRenaming:
		//	source=ID '=' target=ID;
		@Override public ParserRule getRule() { return rule; }

		//source=ID '=' target=ID
		public Group getGroup() { return cGroup; }

		//source=ID
		public Assignment getSourceAssignment_0() { return cSourceAssignment_0; }

		//ID
		public RuleCall getSourceIDTerminalRuleCall_0_0() { return cSourceIDTerminalRuleCall_0_0; }

		//'='
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//target=ID
		public Assignment getTargetAssignment_2() { return cTargetAssignment_2; }

		//ID
		public RuleCall getTargetIDTerminalRuleCall_2_0() { return cTargetIDTerminalRuleCall_2_0; }
	}

	public class ModuleBodyDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ModuleBodyDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModuleBodyDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariablesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariablesVariableParserRuleCall_1_0 = (RuleCall)cVariablesAssignment_1.eContents().get(0);
		private final Assignment cCommandsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCommandsCommandParserRuleCall_2_0 = (RuleCall)cCommandsAssignment_2.eContents().get(0);
		
		//ModuleBodyDeclaration:
		//	{ModuleBodyDeclaration} variables+=Variable*
		//	commands+=Command*;
		@Override public ParserRule getRule() { return rule; }

		//{ModuleBodyDeclaration} variables+=Variable* commands+=Command*
		public Group getGroup() { return cGroup; }

		//{ModuleBodyDeclaration}
		public Action getModuleBodyDeclarationAction_0() { return cModuleBodyDeclarationAction_0; }

		//variables+=Variable*
		public Assignment getVariablesAssignment_1() { return cVariablesAssignment_1; }

		//Variable
		public RuleCall getVariablesVariableParserRuleCall_1_0() { return cVariablesVariableParserRuleCall_1_0; }

		//commands+=Command*
		public Assignment getCommandsAssignment_2() { return cCommandsAssignment_2; }

		//Command
		public RuleCall getCommandsCommandParserRuleCall_2_0() { return cCommandsCommandParserRuleCall_2_0; }
	}

	public class CommandElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Command");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cActAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cActIDTerminalRuleCall_1_0 = (RuleCall)cActAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cGuardAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cGuardExpressionParserRuleCall_3_0 = (RuleCall)cGuardAssignment_3.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cUpdatesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cUpdatesUpdateParserRuleCall_5_0 = (RuleCall)cUpdatesAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cPlusSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cUpdatesAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cUpdatesUpdateParserRuleCall_6_1_0 = (RuleCall)cUpdatesAssignment_6_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//Command:
		//	'[' act=ID? ']' guard=Expression '->' updates+=Update ('+' updates+=Update)* ';';
		@Override public ParserRule getRule() { return rule; }

		//'[' act=ID? ']' guard=Expression '->' updates+=Update ('+' updates+=Update)* ';'
		public Group getGroup() { return cGroup; }

		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//act=ID?
		public Assignment getActAssignment_1() { return cActAssignment_1; }

		//ID
		public RuleCall getActIDTerminalRuleCall_1_0() { return cActIDTerminalRuleCall_1_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }

		//guard=Expression
		public Assignment getGuardAssignment_3() { return cGuardAssignment_3; }

		//Expression
		public RuleCall getGuardExpressionParserRuleCall_3_0() { return cGuardExpressionParserRuleCall_3_0; }

		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_4() { return cHyphenMinusGreaterThanSignKeyword_4; }

		//updates+=Update
		public Assignment getUpdatesAssignment_5() { return cUpdatesAssignment_5; }

		//Update
		public RuleCall getUpdatesUpdateParserRuleCall_5_0() { return cUpdatesUpdateParserRuleCall_5_0; }

		//('+' updates+=Update)*
		public Group getGroup_6() { return cGroup_6; }

		//'+'
		public Keyword getPlusSignKeyword_6_0() { return cPlusSignKeyword_6_0; }

		//updates+=Update
		public Assignment getUpdatesAssignment_6_1() { return cUpdatesAssignment_6_1; }

		//Update
		public RuleCall getUpdatesUpdateParserRuleCall_6_1_0() { return cUpdatesUpdateParserRuleCall_6_1_0; }

		//';'
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
	}

	public class UpdateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Update");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cWeightAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cWeightExpressionParserRuleCall_0_0_0 = (RuleCall)cWeightAssignment_0_0.eContents().get(0);
		private final Keyword cColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsUpdateElementParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cAmpersandKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cElementsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cElementsUpdateElementParserRuleCall_2_1_0 = (RuleCall)cElementsAssignment_2_1.eContents().get(0);
		
		//Update:
		//	(weight=Expression ':')? elements+=UpdateElement ('&' elements+=UpdateElement)*;
		@Override public ParserRule getRule() { return rule; }

		//(weight=Expression ':')? elements+=UpdateElement ('&' elements+=UpdateElement)*
		public Group getGroup() { return cGroup; }

		//(weight=Expression ':')?
		public Group getGroup_0() { return cGroup_0; }

		//weight=Expression
		public Assignment getWeightAssignment_0_0() { return cWeightAssignment_0_0; }

		//Expression
		public RuleCall getWeightExpressionParserRuleCall_0_0_0() { return cWeightExpressionParserRuleCall_0_0_0; }

		//':'
		public Keyword getColonKeyword_0_1() { return cColonKeyword_0_1; }

		//elements+=UpdateElement
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }

		//UpdateElement
		public RuleCall getElementsUpdateElementParserRuleCall_1_0() { return cElementsUpdateElementParserRuleCall_1_0; }

		//('&' elements+=UpdateElement)*
		public Group getGroup_2() { return cGroup_2; }

		//'&'
		public Keyword getAmpersandKeyword_2_0() { return cAmpersandKeyword_2_0; }

		//elements+=UpdateElement
		public Assignment getElementsAssignment_2_1() { return cElementsAssignment_2_1; }

		//UpdateElement
		public RuleCall getElementsUpdateElementParserRuleCall_2_1_0() { return cElementsUpdateElementParserRuleCall_2_1_0; }
	}

	public class UpdateElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.UpdateElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableNEXTIDTerminalRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//UpdateElement:
		//	'(' variable=NEXTID '=' expression=Expression ')';
		@Override public ParserRule getRule() { return rule; }

		//'(' variable=NEXTID '=' expression=Expression ')'
		public Group getGroup() { return cGroup; }

		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//variable=NEXTID
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }

		//NEXTID
		public RuleCall getVariableNEXTIDTerminalRuleCall_1_0() { return cVariableNEXTIDTerminalRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }

		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Variable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeTypeParserRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cInitKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cInitAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cInitExpressionParserRuleCall_3_1_0 = (RuleCall)cInitAssignment_3_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Variable:
		//	name=ID ':' type=Type ('init' init=Expression)? ';';
		@Override public ParserRule getRule() { return rule; }

		//name=ID ':' type=Type ('init' init=Expression)? ';'
		public Group getGroup() { return cGroup; }

		//name=ID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_0() { return cNameIDTerminalRuleCall_0_0; }

		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }

		//type=Type
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//Type
		public RuleCall getTypeTypeParserRuleCall_2_0() { return cTypeTypeParserRuleCall_2_0; }

		//('init' init=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//'init'
		public Keyword getInitKeyword_3_0() { return cInitKeyword_3_0; }

		//init=Expression
		public Assignment getInitAssignment_3_1() { return cInitAssignment_3_1; }

		//Expression
		public RuleCall getInitExpressionParserRuleCall_3_1_0() { return cInitExpressionParserRuleCall_3_1_0; }

		//';'
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntervalTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Type:
		//	BooleanType | IntervalType;
		@Override public ParserRule getRule() { return rule; }

		//BooleanType | IntervalType
		public Alternatives getAlternatives() { return cAlternatives; }

		//BooleanType
		public RuleCall getBooleanTypeParserRuleCall_0() { return cBooleanTypeParserRuleCall_0; }

		//IntervalType
		public RuleCall getIntervalTypeParserRuleCall_1() { return cIntervalTypeParserRuleCall_1; }
	}

	public class IntervalTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.IntervalType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMinAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMinExpressionParserRuleCall_1_0 = (RuleCall)cMinAssignment_1.eContents().get(0);
		private final RuleCall cINTERVALTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cMaxAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cMaxExpressionParserRuleCall_3_0 = (RuleCall)cMaxAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//IntervalType:
		//	'[' min=Expression INTERVAL max=Expression ']';
		@Override public ParserRule getRule() { return rule; }

		//'[' min=Expression INTERVAL max=Expression ']'
		public Group getGroup() { return cGroup; }

		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//min=Expression
		public Assignment getMinAssignment_1() { return cMinAssignment_1; }

		//Expression
		public RuleCall getMinExpressionParserRuleCall_1_0() { return cMinExpressionParserRuleCall_1_0; }

		//INTERVAL
		public RuleCall getINTERVALTerminalRuleCall_2() { return cINTERVALTerminalRuleCall_2; }

		//max=Expression
		public Assignment getMaxAssignment_3() { return cMaxAssignment_3; }

		//Expression
		public RuleCall getMaxExpressionParserRuleCall_3_0() { return cMaxExpressionParserRuleCall_3_0; }

		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}

	public class BooleanTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.BooleanType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBooleanTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBoolKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//BooleanType:
		//	{BooleanType}
		//	'bool';
		@Override public ParserRule getRule() { return rule; }

		//{BooleanType} 'bool'
		public Group getGroup() { return cGroup; }

		//{BooleanType}
		public Action getBooleanTypeAction_0() { return cBooleanTypeAction_0; }

		//'bool'
		public Keyword getBoolKeyword_1() { return cBoolKeyword_1; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Expression");
		private final RuleCall cIfThenElseParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	IfThenElse;
		@Override public ParserRule getRule() { return rule; }

		//IfThenElse
		public RuleCall getIfThenElseParserRuleCall() { return cIfThenElseParserRuleCall; }
	}

	public class IfThenElseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.IfThenElse");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cImpliesParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfThenElseGuardAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cThenCaseAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cThenCaseIfThenElseParserRuleCall_1_2_0 = (RuleCall)cThenCaseAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cElseCaseAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cElseCaseImpliesParserRuleCall_1_4_0 = (RuleCall)cElseCaseAssignment_1_4.eContents().get(0);
		
		//IfThenElse Expression:
		//	Implies ({IfThenElse.guard=current} '?' thenCase=IfThenElse ':' elseCase=Implies)*
		@Override public ParserRule getRule() { return rule; }

		//Implies ({IfThenElse.guard=current} '?' thenCase=IfThenElse ':' elseCase=Implies)*
		public Group getGroup() { return cGroup; }

		//Implies
		public RuleCall getImpliesParserRuleCall_0() { return cImpliesParserRuleCall_0; }

		//({IfThenElse.guard=current} '?' thenCase=IfThenElse ':' elseCase=Implies)*
		public Group getGroup_1() { return cGroup_1; }

		//{IfThenElse.guard=current}
		public Action getIfThenElseGuardAction_1_0() { return cIfThenElseGuardAction_1_0; }

		//'?'
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }

		//thenCase=IfThenElse
		public Assignment getThenCaseAssignment_1_2() { return cThenCaseAssignment_1_2; }

		//IfThenElse
		public RuleCall getThenCaseIfThenElseParserRuleCall_1_2_0() { return cThenCaseIfThenElseParserRuleCall_1_2_0; }

		//':'
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }

		//elseCase=Implies
		public Assignment getElseCaseAssignment_1_4() { return cElseCaseAssignment_1_4; }

		//Implies
		public RuleCall getElseCaseImpliesParserRuleCall_1_4_0() { return cElseCaseImpliesParserRuleCall_1_4_0; }
	}

	public class ImpliesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Implies");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIfAndOnlyIfParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cImpliesLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightIfAndOnlyIfParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Implies Expression:
		//	IfAndOnlyIf ({Implies.left=current} '=>' right=IfAndOnlyIf)*
		@Override public ParserRule getRule() { return rule; }

		//IfAndOnlyIf ({Implies.left=current} '=>' right=IfAndOnlyIf)*
		public Group getGroup() { return cGroup; }

		//IfAndOnlyIf
		public RuleCall getIfAndOnlyIfParserRuleCall_0() { return cIfAndOnlyIfParserRuleCall_0; }

		//({Implies.left=current} '=>' right=IfAndOnlyIf)*
		public Group getGroup_1() { return cGroup_1; }

		//{Implies.left=current}
		public Action getImpliesLeftAction_1_0() { return cImpliesLeftAction_1_0; }

		//'=>'
		public Keyword getEqualsSignGreaterThanSignKeyword_1_1() { return cEqualsSignGreaterThanSignKeyword_1_1; }

		//right=IfAndOnlyIf
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//IfAndOnlyIf
		public RuleCall getRightIfAndOnlyIfParserRuleCall_1_2_0() { return cRightIfAndOnlyIfParserRuleCall_1_2_0; }
	}

	public class IfAndOnlyIfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.IfAndOnlyIf");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfAndOnlyIfLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignGreaterThanSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightOrExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//IfAndOnlyIf Expression:
		//	OrExpression ({IfAndOnlyIf.left=current} '<=>' right=OrExpression)*
		@Override public ParserRule getRule() { return rule; }

		//OrExpression ({IfAndOnlyIf.left=current} '<=>' right=OrExpression)*
		public Group getGroup() { return cGroup; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//({IfAndOnlyIf.left=current} '<=>' right=OrExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{IfAndOnlyIf.left=current}
		public Action getIfAndOnlyIfLeftAction_1_0() { return cIfAndOnlyIfLeftAction_1_0; }

		//'<=>'
		public Keyword getLessThanSignEqualsSignGreaterThanSignKeyword_1_1() { return cLessThanSignEqualsSignGreaterThanSignKeyword_1_1; }

		//right=OrExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//OrExpression
		public RuleCall getRightOrExpressionParserRuleCall_1_2_0() { return cRightOrExpressionParserRuleCall_1_2_0; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//OrExpression Expression:
		//	AndExpression ({OrExpression.left=current} '|' right=AndExpression)*
		@Override public ParserRule getRule() { return rule; }

		//AndExpression ({OrExpression.left=current} '|' right=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({OrExpression.left=current} '|' right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrExpression.left=current}
		public Action getOrExpressionLeftAction_1_0() { return cOrExpressionLeftAction_1_0; }

		//'|'
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNegationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNegationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression Expression:
		//	Negation ({AndExpression.left=current} '&' right=Negation)*
		@Override public ParserRule getRule() { return rule; }

		//Negation ({AndExpression.left=current} '&' right=Negation)*
		public Group getGroup() { return cGroup; }

		//Negation
		public RuleCall getNegationParserRuleCall_0() { return cNegationParserRuleCall_0; }

		//({AndExpression.left=current} '&' right=Negation)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndExpression.left=current}
		public Action getAndExpressionLeftAction_1_0() { return cAndExpressionLeftAction_1_0; }

		//'&'
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//right=Negation
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Negation
		public RuleCall getRightNegationParserRuleCall_1_2_0() { return cRightNegationParserRuleCall_1_2_0; }
	}

	public class NegationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Negation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cNegationAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cArgAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cArgNegationParserRuleCall_0_2_0 = (RuleCall)cArgAssignment_0_2.eContents().get(0);
		private final RuleCall cRelExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Negation Expression:
		//	'!' {Negation} arg=Negation | RelExpression
		@Override public ParserRule getRule() { return rule; }

		//'!' {Negation} arg=Negation | RelExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//'!' {Negation} arg=Negation
		public Group getGroup_0() { return cGroup_0; }

		//'!'
		public Keyword getExclamationMarkKeyword_0_0() { return cExclamationMarkKeyword_0_0; }

		//{Negation}
		public Action getNegationAction_0_1() { return cNegationAction_0_1; }

		//arg=Negation
		public Assignment getArgAssignment_0_2() { return cArgAssignment_0_2; }

		//Negation
		public RuleCall getArgNegationParserRuleCall_0_2_0() { return cArgNegationParserRuleCall_0_2_0; }

		//RelExpression
		public RuleCall getRelExpressionParserRuleCall_1() { return cRelExpressionParserRuleCall_1; }
	}

	public class RelExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.RelExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSumExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cRelExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cRelopAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRelopRelationsEnumRuleCall_1_1_0 = (RuleCall)cRelopAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSumExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//RelExpression Expression:
		//	SumExpression ({RelExpression.left=current} relop=Relations right=SumExpression)*
		@Override public ParserRule getRule() { return rule; }

		//SumExpression ({RelExpression.left=current} relop=Relations right=SumExpression)*
		public Group getGroup() { return cGroup; }

		//SumExpression
		public RuleCall getSumExpressionParserRuleCall_0() { return cSumExpressionParserRuleCall_0; }

		//({RelExpression.left=current} relop=Relations right=SumExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{RelExpression.left=current}
		public Action getRelExpressionLeftAction_1_0() { return cRelExpressionLeftAction_1_0; }

		//relop=Relations
		public Assignment getRelopAssignment_1_1() { return cRelopAssignment_1_1; }

		//Relations
		public RuleCall getRelopRelationsEnumRuleCall_1_1_0() { return cRelopRelationsEnumRuleCall_1_1_0; }

		//right=SumExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SumExpression
		public RuleCall getRightSumExpressionParserRuleCall_1_2_0() { return cRightSumExpressionParserRuleCall_1_2_0; }
	}

	public class SumExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.SumExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMulExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSumExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightMulExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SumExpression Expression:
		//	MulExpression ({SumExpression.left=current} op=('+' | '-') right=MulExpression)*
		@Override public ParserRule getRule() { return rule; }

		//MulExpression ({SumExpression.left=current} op=('+' | '-') right=MulExpression)*
		public Group getGroup() { return cGroup; }

		//MulExpression
		public RuleCall getMulExpressionParserRuleCall_0() { return cMulExpressionParserRuleCall_0; }

		//({SumExpression.left=current} op=('+' | '-') right=MulExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{SumExpression.left=current}
		public Action getSumExpressionLeftAction_1_0() { return cSumExpressionLeftAction_1_0; }

		//op=('+' | '-')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//('+' | '-')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//'+'
		public Keyword getOpPlusSignKeyword_1_1_0_0() { return cOpPlusSignKeyword_1_1_0_0; }

		//'-'
		public Keyword getOpHyphenMinusKeyword_1_1_0_1() { return cOpHyphenMinusKeyword_1_1_0_1; }

		//right=MulExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//MulExpression
		public RuleCall getRightMulExpressionParserRuleCall_1_2_0() { return cRightMulExpressionParserRuleCall_1_2_0; }
	}

	public class MulExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.MulExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBaseExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMulExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final Alternatives cOpAlternatives_1_1_0 = (Alternatives)cOpAssignment_1_1.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_1_1_0_0 = (Keyword)cOpAlternatives_1_1_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_1_1_0_1 = (Keyword)cOpAlternatives_1_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBaseExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//MulExpression Expression:
		//	BaseExpression ({MulExpression.left=current} op=('*' | '/') right=BaseExpression)*
		@Override public ParserRule getRule() { return rule; }

		//BaseExpression ({MulExpression.left=current} op=('*' | '/') right=BaseExpression)*
		public Group getGroup() { return cGroup; }

		//BaseExpression
		public RuleCall getBaseExpressionParserRuleCall_0() { return cBaseExpressionParserRuleCall_0; }

		//({MulExpression.left=current} op=('*' | '/') right=BaseExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{MulExpression.left=current}
		public Action getMulExpressionLeftAction_1_0() { return cMulExpressionLeftAction_1_0; }

		//op=('*' | '/')
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//('*' | '/')
		public Alternatives getOpAlternatives_1_1_0() { return cOpAlternatives_1_1_0; }

		//'*'
		public Keyword getOpAsteriskKeyword_1_1_0_0() { return cOpAsteriskKeyword_1_1_0_0; }

		//'/'
		public Keyword getOpSolidusKeyword_1_1_0_1() { return cOpSolidusKeyword_1_1_0_1; }

		//right=BaseExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BaseExpression
		public RuleCall getRightBaseExpressionParserRuleCall_1_2_0() { return cRightBaseExpressionParserRuleCall_1_2_0; }
	}

	public class BaseExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.BaseExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumericalValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTrueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFalseParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final Group cGroup_4 = (Group)cAlternatives.eContents().get(4);
		private final Keyword cLeftParenthesisKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_4_1 = (RuleCall)cGroup_4.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final RuleCall cMinFunctionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cMaxFunctionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cPowFunctionParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cFloorFunctionParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cCeilFunctionParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cModFunctionParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cLogFunctionParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		
		//BaseExpression Expression:
		//	NumericalValue
		//	| Reference
		//	| True
		//	| False
		//	| '(' Expression ')'
		//	| MinFunction
		//	| MaxFunction
		//	| PowFunction
		//	| FloorFunction
		//	| CeilFunction
		//	| ModFunction
		//	| LogFunction
		@Override public ParserRule getRule() { return rule; }

		//NumericalValue | Reference | True | False | '(' Expression ')' | MinFunction | MaxFunction | PowFunction | FloorFunction
		//| CeilFunction | ModFunction | LogFunction
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumericalValue
		public RuleCall getNumericalValueParserRuleCall_0() { return cNumericalValueParserRuleCall_0; }

		//Reference
		public RuleCall getReferenceParserRuleCall_1() { return cReferenceParserRuleCall_1; }

		//True
		public RuleCall getTrueParserRuleCall_2() { return cTrueParserRuleCall_2; }

		//False
		public RuleCall getFalseParserRuleCall_3() { return cFalseParserRuleCall_3; }

		//'(' Expression ')'
		public Group getGroup_4() { return cGroup_4; }

		//'('
		public Keyword getLeftParenthesisKeyword_4_0() { return cLeftParenthesisKeyword_4_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_4_1() { return cExpressionParserRuleCall_4_1; }

		//')'
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }

		//MinFunction
		public RuleCall getMinFunctionParserRuleCall_5() { return cMinFunctionParserRuleCall_5; }

		//MaxFunction
		public RuleCall getMaxFunctionParserRuleCall_6() { return cMaxFunctionParserRuleCall_6; }

		//PowFunction
		public RuleCall getPowFunctionParserRuleCall_7() { return cPowFunctionParserRuleCall_7; }

		//FloorFunction
		public RuleCall getFloorFunctionParserRuleCall_8() { return cFloorFunctionParserRuleCall_8; }

		//CeilFunction
		public RuleCall getCeilFunctionParserRuleCall_9() { return cCeilFunctionParserRuleCall_9; }

		//ModFunction
		public RuleCall getModFunctionParserRuleCall_10() { return cModFunctionParserRuleCall_10; }

		//LogFunction
		public RuleCall getLogFunctionParserRuleCall_11() { return cLogFunctionParserRuleCall_11; }
	}

	public class LogFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.LogFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLogKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgumentAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgumentExpressionParserRuleCall_2_0 = (RuleCall)cArgumentAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBaseAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBaseExpressionParserRuleCall_4_0 = (RuleCall)cBaseAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//LogFunction:
		//	'log' '(' argument=Expression ',' base=Expression ')';
		@Override public ParserRule getRule() { return rule; }

		//'log' '(' argument=Expression ',' base=Expression ')'
		public Group getGroup() { return cGroup; }

		//'log'
		public Keyword getLogKeyword_0() { return cLogKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//argument=Expression
		public Assignment getArgumentAssignment_2() { return cArgumentAssignment_2; }

		//Expression
		public RuleCall getArgumentExpressionParserRuleCall_2_0() { return cArgumentExpressionParserRuleCall_2_0; }

		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//base=Expression
		public Assignment getBaseAssignment_4() { return cBaseAssignment_4; }

		//Expression
		public RuleCall getBaseExpressionParserRuleCall_4_0() { return cBaseExpressionParserRuleCall_4_0; }

		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class ModFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ModFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cDividendAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDividendExpressionParserRuleCall_2_0 = (RuleCall)cDividendAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cDivisorAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDivisorExpressionParserRuleCall_4_0 = (RuleCall)cDivisorAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//ModFunction:
		//	'mod' '(' dividend=Expression ',' divisor=Expression ')';
		@Override public ParserRule getRule() { return rule; }

		//'mod' '(' dividend=Expression ',' divisor=Expression ')'
		public Group getGroup() { return cGroup; }

		//'mod'
		public Keyword getModKeyword_0() { return cModKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//dividend=Expression
		public Assignment getDividendAssignment_2() { return cDividendAssignment_2; }

		//Expression
		public RuleCall getDividendExpressionParserRuleCall_2_0() { return cDividendExpressionParserRuleCall_2_0; }

		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//divisor=Expression
		public Assignment getDivisorAssignment_4() { return cDivisorAssignment_4; }

		//Expression
		public RuleCall getDivisorExpressionParserRuleCall_4_0() { return cDivisorExpressionParserRuleCall_4_0; }

		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class CeilFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.CeilFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCeilKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgExpressionParserRuleCall_2_0 = (RuleCall)cArgAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//CeilFunction:
		//	'ceil' '(' arg=Expression ')';
		@Override public ParserRule getRule() { return rule; }

		//'ceil' '(' arg=Expression ')'
		public Group getGroup() { return cGroup; }

		//'ceil'
		public Keyword getCeilKeyword_0() { return cCeilKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//arg=Expression
		public Assignment getArgAssignment_2() { return cArgAssignment_2; }

		//Expression
		public RuleCall getArgExpressionParserRuleCall_2_0() { return cArgExpressionParserRuleCall_2_0; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class FloorFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.FloorFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFloorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgExpressionParserRuleCall_2_0 = (RuleCall)cArgAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FloorFunction:
		//	'floor' '(' arg=Expression ')';
		@Override public ParserRule getRule() { return rule; }

		//'floor' '(' arg=Expression ')'
		public Group getGroup() { return cGroup; }

		//'floor'
		public Keyword getFloorKeyword_0() { return cFloorKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//arg=Expression
		public Assignment getArgAssignment_2() { return cArgAssignment_2; }

		//Expression
		public RuleCall getArgExpressionParserRuleCall_2_0() { return cArgExpressionParserRuleCall_2_0; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class PowFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.PowFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPowKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cBaseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cBaseExpressionParserRuleCall_2_0 = (RuleCall)cBaseAssignment_2.eContents().get(0);
		private final Keyword cCommaKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExponentAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExponentExpressionParserRuleCall_4_0 = (RuleCall)cExponentAssignment_4.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//PowFunction:
		//	'pow' '(' base=Expression ',' exponent=Expression ')';
		@Override public ParserRule getRule() { return rule; }

		//'pow' '(' base=Expression ',' exponent=Expression ')'
		public Group getGroup() { return cGroup; }

		//'pow'
		public Keyword getPowKeyword_0() { return cPowKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//base=Expression
		public Assignment getBaseAssignment_2() { return cBaseAssignment_2; }

		//Expression
		public RuleCall getBaseExpressionParserRuleCall_2_0() { return cBaseExpressionParserRuleCall_2_0; }

		//','
		public Keyword getCommaKeyword_3() { return cCommaKeyword_3; }

		//exponent=Expression
		public Assignment getExponentAssignment_4() { return cExponentAssignment_4; }

		//Expression
		public RuleCall getExponentExpressionParserRuleCall_4_0() { return cExponentExpressionParserRuleCall_4_0; }

		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}

	public class MaxFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.MaxFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMaxKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgsExpressionParserRuleCall_2_0 = (RuleCall)cArgsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cArgsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cArgsExpressionParserRuleCall_3_1_0 = (RuleCall)cArgsAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MaxFunction:
		//	'max' '(' args+=Expression (',' args+=Expression)+ ')';
		@Override public ParserRule getRule() { return rule; }

		//'max' '(' args+=Expression (',' args+=Expression)+ ')'
		public Group getGroup() { return cGroup; }

		//'max'
		public Keyword getMaxKeyword_0() { return cMaxKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//args+=Expression
		public Assignment getArgsAssignment_2() { return cArgsAssignment_2; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_2_0() { return cArgsExpressionParserRuleCall_2_0; }

		//(',' args+=Expression)+
		public Group getGroup_3() { return cGroup_3; }

		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//args+=Expression
		public Assignment getArgsAssignment_3_1() { return cArgsAssignment_3_1; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_3_1_0() { return cArgsExpressionParserRuleCall_3_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class MinFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.MinFunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMinKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cArgsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cArgsExpressionParserRuleCall_2_0 = (RuleCall)cArgsAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cArgsAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cArgsExpressionParserRuleCall_3_1_0 = (RuleCall)cArgsAssignment_3_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//MinFunction:
		//	'min' '(' args+=Expression (',' args+=Expression)+ ')';
		@Override public ParserRule getRule() { return rule; }

		//'min' '(' args+=Expression (',' args+=Expression)+ ')'
		public Group getGroup() { return cGroup; }

		//'min'
		public Keyword getMinKeyword_0() { return cMinKeyword_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//args+=Expression
		public Assignment getArgsAssignment_2() { return cArgsAssignment_2; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_2_0() { return cArgsExpressionParserRuleCall_2_0; }

		//(',' args+=Expression)+
		public Group getGroup_3() { return cGroup_3; }

		//','
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//args+=Expression
		public Assignment getArgsAssignment_3_1() { return cArgsAssignment_3_1; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_3_1_0() { return cArgsExpressionParserRuleCall_3_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class TrueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.True");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTrueAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTrueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		/// *
		//    log(x,b), which computes the logarithm of x to base b. 
		//    *  * / True:
		//	{True}
		//	'true';
		@Override public ParserRule getRule() { return rule; }

		//{True} 'true'
		public Group getGroup() { return cGroup; }

		//{True}
		public Action getTrueAction_0() { return cTrueAction_0; }

		//'true'
		public Keyword getTrueKeyword_1() { return cTrueKeyword_1; }
	}

	public class FalseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.False");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFalseAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFalseKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//False:
		//	{False}
		//	'false';
		@Override public ParserRule getRule() { return rule; }

		//{False} 'false'
		public Group getGroup() { return cGroup; }

		//{False}
		public Action getFalseAction_0() { return cFalseAction_0; }

		//'false'
		public Keyword getFalseKeyword_1() { return cFalseKeyword_1; }
	}

	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Reference");
		private final Assignment cReferenceAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cReferenceIDTerminalRuleCall_0 = (RuleCall)cReferenceAssignment.eContents().get(0);
		
		//Reference:
		//	reference=ID;
		@Override public ParserRule getRule() { return rule; }

		//reference=ID
		public Assignment getReferenceAssignment() { return cReferenceAssignment; }

		//ID
		public RuleCall getReferenceIDTerminalRuleCall_0() { return cReferenceIDTerminalRuleCall_0; }
	}

	public class NumericalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.NumericalValue");
		private final RuleCall cDecimalLiteralParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//NumericalValue Expression:
		//	DecimalLiteral
		@Override public ParserRule getRule() { return rule; }

		//DecimalLiteral
		public RuleCall getDecimalLiteralParserRuleCall() { return cDecimalLiteralParserRuleCall; }
	}

	public class DecimalLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.DecimalLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIntegerLiteralParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cDecimalLiteralIntegerPartAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cDecimalPartAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cDecimalPartDECIMAL_PARTTerminalRuleCall_1_1_0 = (RuleCall)cDecimalPartAssignment_1_1.eContents().get(0);
		
		/// * 
		//ExponentialLiteral returns NumericalValue:
		//	DecimalLiteral ({ExponentialLiteral.realNumber = current} ('e'|'E') exp=INT)?
		//;
		// * / DecimalLiteral NumericalValue:
		//	IntegerLiteral ({DecimalLiteral.integerPart=current} decimalPart=DECIMAL_PART)?
		@Override public ParserRule getRule() { return rule; }

		//IntegerLiteral ({DecimalLiteral.integerPart=current} decimalPart=DECIMAL_PART)?
		public Group getGroup() { return cGroup; }

		//IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_0() { return cIntegerLiteralParserRuleCall_0; }

		//({DecimalLiteral.integerPart=current} decimalPart=DECIMAL_PART)?
		public Group getGroup_1() { return cGroup_1; }

		//{DecimalLiteral.integerPart=current}
		public Action getDecimalLiteralIntegerPartAction_1_0() { return cDecimalLiteralIntegerPartAction_1_0; }

		//decimalPart=DECIMAL_PART
		public Assignment getDecimalPartAssignment_1_1() { return cDecimalPartAssignment_1_1; }

		//DECIMAL_PART
		public RuleCall getDecimalPartDECIMAL_PARTTerminalRuleCall_1_1_0() { return cDecimalPartDECIMAL_PARTTerminalRuleCall_1_1_0; }
	}

	public class IntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.IntegerLiteral");
		private final Assignment cIntegerPartAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIntegerPartINTTerminalRuleCall_0 = (RuleCall)cIntegerPartAssignment.eContents().get(0);
		
		////NumericalLiteral:
		////	integerPart=INT
		////;
		//IntegerLiteral:
		//	integerPart=INT;
		@Override public ParserRule getRule() { return rule; }

		//integerPart=INT
		public Assignment getIntegerPartAssignment() { return cIntegerPartAssignment; }

		//INT
		public RuleCall getIntegerPartINTTerminalRuleCall_0() { return cIntegerPartINTTerminalRuleCall_0; }
	}

	public class ModelTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ModelType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cDTMCTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMDPTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCTMCTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//ModelType:
		//	DTMC | MDP | CTMC;
		@Override public ParserRule getRule() { return rule; }

		//DTMC | MDP | CTMC
		public Alternatives getAlternatives() { return cAlternatives; }

		//DTMC
		public RuleCall getDTMCTerminalRuleCall_0() { return cDTMCTerminalRuleCall_0; }

		//MDP
		public RuleCall getMDPTerminalRuleCall_1() { return cMDPTerminalRuleCall_1; }

		//CTMC
		public RuleCall getCTMCTerminalRuleCall_2() { return cCTMCTerminalRuleCall_2; }
	}
	
	
	public class ConstantTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.ConstantType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCINTIntKeyword_0_0 = (Keyword)cCINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCBOOLEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCBOOLBoolKeyword_1_0 = (Keyword)cCBOOLEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCDOUBLEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCDOUBLEDoubleKeyword_2_0 = (Keyword)cCDOUBLEEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ConstantType:
		//	CINT='int' | CBOOL='bool' | CDOUBLE='double';
		public EnumRule getRule() { return rule; }

		//CINT='int' | CBOOL='bool' | CDOUBLE='double'
		public Alternatives getAlternatives() { return cAlternatives; }

		//CINT='int'
		public EnumLiteralDeclaration getCINTEnumLiteralDeclaration_0() { return cCINTEnumLiteralDeclaration_0; }

		//'int'
		public Keyword getCINTIntKeyword_0_0() { return cCINTIntKeyword_0_0; }

		//CBOOL='bool'
		public EnumLiteralDeclaration getCBOOLEnumLiteralDeclaration_1() { return cCBOOLEnumLiteralDeclaration_1; }

		//'bool'
		public Keyword getCBOOLBoolKeyword_1_0() { return cCBOOLBoolKeyword_1_0; }

		//CDOUBLE='double'
		public EnumLiteralDeclaration getCDOUBLEEnumLiteralDeclaration_2() { return cCDOUBLEEnumLiteralDeclaration_2; }

		//'double'
		public Keyword getCDOUBLEDoubleKeyword_2_0() { return cCDOUBLEDoubleKeyword_2_0; }
	}

	public class RelationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.Relations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLSSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLSSLessThanSignKeyword_0_0 = (Keyword)cLSSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLEQEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLEQLessThanSignEqualsSignKeyword_1_0 = (Keyword)cLEQEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQEqualsSignKeyword_2_0 = (Keyword)cEQEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNEQEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNEQExclamationMarkEqualsSignKeyword_3_0 = (Keyword)cNEQEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGTREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGTRGreaterThanSignKeyword_4_0 = (Keyword)cGTREnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGEQEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGEQGreaterThanSignEqualsSignKeyword_5_0 = (Keyword)cGEQEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum Relations:
		//	LSS='<'
		//	| LEQ='<='
		//	| EQ='='
		//	| NEQ='!='
		//	| GTR='>'
		//	| GEQ='>=';
		public EnumRule getRule() { return rule; }

		//LSS='<' | LEQ='<=' | EQ='=' | NEQ='!=' | GTR='>' | GEQ='>='
		public Alternatives getAlternatives() { return cAlternatives; }

		//LSS='<'
		public EnumLiteralDeclaration getLSSEnumLiteralDeclaration_0() { return cLSSEnumLiteralDeclaration_0; }

		//'<'
		public Keyword getLSSLessThanSignKeyword_0_0() { return cLSSLessThanSignKeyword_0_0; }

		//LEQ='<='
		public EnumLiteralDeclaration getLEQEnumLiteralDeclaration_1() { return cLEQEnumLiteralDeclaration_1; }

		//'<='
		public Keyword getLEQLessThanSignEqualsSignKeyword_1_0() { return cLEQLessThanSignEqualsSignKeyword_1_0; }

		//EQ='='
		public EnumLiteralDeclaration getEQEnumLiteralDeclaration_2() { return cEQEnumLiteralDeclaration_2; }

		//'='
		public Keyword getEQEqualsSignKeyword_2_0() { return cEQEqualsSignKeyword_2_0; }

		//NEQ='!='
		public EnumLiteralDeclaration getNEQEnumLiteralDeclaration_3() { return cNEQEnumLiteralDeclaration_3; }

		//'!='
		public Keyword getNEQExclamationMarkEqualsSignKeyword_3_0() { return cNEQExclamationMarkEqualsSignKeyword_3_0; }

		//GTR='>'
		public EnumLiteralDeclaration getGTREnumLiteralDeclaration_4() { return cGTREnumLiteralDeclaration_4; }

		//'>'
		public Keyword getGTRGreaterThanSignKeyword_4_0() { return cGTRGreaterThanSignKeyword_4_0; }

		//GEQ='>='
		public EnumLiteralDeclaration getGEQEnumLiteralDeclaration_5() { return cGEQEnumLiteralDeclaration_5; }

		//'>='
		public Keyword getGEQGreaterThanSignEqualsSignKeyword_5_0() { return cGEQGreaterThanSignEqualsSignKeyword_5_0; }
	}
	
	private final ModelElements pModel;
	private final ElementElements pElement;
	private final PathFormulaDeclarationElements pPathFormulaDeclaration;
	private final StateFormulaDeclarationElements pStateFormulaDeclaration;
	private final PathFormulaElements pPathFormula;
	private final UntilFormulaElements pUntilFormula;
	private final BoundElements pBound;
	private final NextFormulaElements pNextFormula;
	private final StateFormulaElements pStateFormula;
	private final StateOrElements pStateOr;
	private final StateAndElements pStateAnd;
	private final BaseStateFormulaElements pBaseStateFormula;
	private final ProbabilityFormulaElements pProbabilityFormula;
	private final NegationFormulaElements pNegationFormula;
	private final AtomicStateFormulaElements pAtomicStateFormula;
	private final PrismSystemElements pPrismSystem;
	private final AlphabetisedParallelCompositionElements pAlphabetisedParallelComposition;
	private final AsynchronousParallelCompositionElements pAsynchronousParallelComposition;
	private final RestrictedParallelCompositionElements pRestrictedParallelComposition;
	private final HidingElements pHiding;
	private final RenamingElements pRenaming;
	private final ActionRenamingElements pActionRenaming;
	private final BaseModuleElements pBaseModule;
	private final ModuleReferenceElements pModuleReference;
	private final GlobalElements pGlobal;
	private final LabelElements pLabel;
	private final FormulaElements pFormula;
	private final InitPredicateElements pInitPredicate;
	private final RewardElements pReward;
	private final RewardCaseElements pRewardCase;
	private final ConstantElements pConstant;
	private final ConstantTypeElements eConstantType;
	private final ModuleElements pModule;
	private final ModuleBodyElements pModuleBody;
	private final VariableRenamingElements pVariableRenaming;
	private final SymbolRenamingElements pSymbolRenaming;
	private final ModuleBodyDeclarationElements pModuleBodyDeclaration;
	private final CommandElements pCommand;
	private final UpdateElements pUpdate;
	private final UpdateElementElements pUpdateElement;
	private final TerminalRule tNEXTID;
	private final VariableElements pVariable;
	private final TypeElements pType;
	private final IntervalTypeElements pIntervalType;
	private final BooleanTypeElements pBooleanType;
	private final ExpressionElements pExpression;
	private final IfThenElseElements pIfThenElse;
	private final ImpliesElements pImplies;
	private final IfAndOnlyIfElements pIfAndOnlyIf;
	private final OrExpressionElements pOrExpression;
	private final AndExpressionElements pAndExpression;
	private final NegationElements pNegation;
	private final RelExpressionElements pRelExpression;
	private final RelationsElements eRelations;
	private final SumExpressionElements pSumExpression;
	private final MulExpressionElements pMulExpression;
	private final BaseExpressionElements pBaseExpression;
	private final LogFunctionElements pLogFunction;
	private final ModFunctionElements pModFunction;
	private final CeilFunctionElements pCeilFunction;
	private final FloorFunctionElements pFloorFunction;
	private final PowFunctionElements pPowFunction;
	private final MaxFunctionElements pMaxFunction;
	private final MinFunctionElements pMinFunction;
	private final TrueElements pTrue;
	private final FalseElements pFalse;
	private final ReferenceElements pReference;
	private final NumericalValueElements pNumericalValue;
	private final DecimalLiteralElements pDecimalLiteral;
	private final IntegerLiteralElements pIntegerLiteral;
	private final TerminalRule tDTMC;
	private final TerminalRule tMDP;
	private final TerminalRule tCTMC;
	private final ModelTypeElements pModelType;
	private final TerminalRule tSTRING;
	private final TerminalRule tINTERVAL;
	private final TerminalRule tDECIMAL_PART;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public PrismGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pElement = new ElementElements();
		this.pPathFormulaDeclaration = new PathFormulaDeclarationElements();
		this.pStateFormulaDeclaration = new StateFormulaDeclarationElements();
		this.pPathFormula = new PathFormulaElements();
		this.pUntilFormula = new UntilFormulaElements();
		this.pBound = new BoundElements();
		this.pNextFormula = new NextFormulaElements();
		this.pStateFormula = new StateFormulaElements();
		this.pStateOr = new StateOrElements();
		this.pStateAnd = new StateAndElements();
		this.pBaseStateFormula = new BaseStateFormulaElements();
		this.pProbabilityFormula = new ProbabilityFormulaElements();
		this.pNegationFormula = new NegationFormulaElements();
		this.pAtomicStateFormula = new AtomicStateFormulaElements();
		this.pPrismSystem = new PrismSystemElements();
		this.pAlphabetisedParallelComposition = new AlphabetisedParallelCompositionElements();
		this.pAsynchronousParallelComposition = new AsynchronousParallelCompositionElements();
		this.pRestrictedParallelComposition = new RestrictedParallelCompositionElements();
		this.pHiding = new HidingElements();
		this.pRenaming = new RenamingElements();
		this.pActionRenaming = new ActionRenamingElements();
		this.pBaseModule = new BaseModuleElements();
		this.pModuleReference = new ModuleReferenceElements();
		this.pGlobal = new GlobalElements();
		this.pLabel = new LabelElements();
		this.pFormula = new FormulaElements();
		this.pInitPredicate = new InitPredicateElements();
		this.pReward = new RewardElements();
		this.pRewardCase = new RewardCaseElements();
		this.pConstant = new ConstantElements();
		this.eConstantType = new ConstantTypeElements();
		this.pModule = new ModuleElements();
		this.pModuleBody = new ModuleBodyElements();
		this.pVariableRenaming = new VariableRenamingElements();
		this.pSymbolRenaming = new SymbolRenamingElements();
		this.pModuleBodyDeclaration = new ModuleBodyDeclarationElements();
		this.pCommand = new CommandElements();
		this.pUpdate = new UpdateElements();
		this.pUpdateElement = new UpdateElementElements();
		this.tNEXTID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.NEXTID");
		this.pVariable = new VariableElements();
		this.pType = new TypeElements();
		this.pIntervalType = new IntervalTypeElements();
		this.pBooleanType = new BooleanTypeElements();
		this.pExpression = new ExpressionElements();
		this.pIfThenElse = new IfThenElseElements();
		this.pImplies = new ImpliesElements();
		this.pIfAndOnlyIf = new IfAndOnlyIfElements();
		this.pOrExpression = new OrExpressionElements();
		this.pAndExpression = new AndExpressionElements();
		this.pNegation = new NegationElements();
		this.pRelExpression = new RelExpressionElements();
		this.eRelations = new RelationsElements();
		this.pSumExpression = new SumExpressionElements();
		this.pMulExpression = new MulExpressionElements();
		this.pBaseExpression = new BaseExpressionElements();
		this.pLogFunction = new LogFunctionElements();
		this.pModFunction = new ModFunctionElements();
		this.pCeilFunction = new CeilFunctionElements();
		this.pFloorFunction = new FloorFunctionElements();
		this.pPowFunction = new PowFunctionElements();
		this.pMaxFunction = new MaxFunctionElements();
		this.pMinFunction = new MinFunctionElements();
		this.pTrue = new TrueElements();
		this.pFalse = new FalseElements();
		this.pReference = new ReferenceElements();
		this.pNumericalValue = new NumericalValueElements();
		this.pDecimalLiteral = new DecimalLiteralElements();
		this.pIntegerLiteral = new IntegerLiteralElements();
		this.tDTMC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.DTMC");
		this.tMDP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.MDP");
		this.tCTMC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.CTMC");
		this.pModelType = new ModelTypeElements();
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.STRING");
		this.tINTERVAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.INTERVAL");
		this.tDECIMAL_PART = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.cmg.ml.sam.xtext.prism.Prism.DECIMAL_PART");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.cmg.ml.sam.xtext.prism.Prism".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	type=ModelType
	//	elements+=Element*;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}

	//Element:
	//	Module
	//	| Global
	//	| Constant
	//	| Reward
	//	| InitPredicate
	//	| Formula
	//	| Label
	//	| PrismSystem
	//	| PathFormulaDeclaration
	//	| StateFormulaDeclaration;
	public ElementElements getElementAccess() {
		return pElement;
	}
	
	public ParserRule getElementRule() {
		return getElementAccess().getRule();
	}

	//PathFormulaDeclaration:
	//	'pathformula' name=ID '=' formula=PathFormula ';';
	public PathFormulaDeclarationElements getPathFormulaDeclarationAccess() {
		return pPathFormulaDeclaration;
	}
	
	public ParserRule getPathFormulaDeclarationRule() {
		return getPathFormulaDeclarationAccess().getRule();
	}

	//StateFormulaDeclaration:
	//	'stateformula' name=ID '=' formula=StateFormula ';';
	public StateFormulaDeclarationElements getStateFormulaDeclarationAccess() {
		return pStateFormulaDeclaration;
	}
	
	public ParserRule getStateFormulaDeclarationRule() {
		return getStateFormulaDeclarationAccess().getRule();
	}

	//PathFormula:
	//	NextFormula | UntilFormula;
	public PathFormulaElements getPathFormulaAccess() {
		return pPathFormula;
	}
	
	public ParserRule getPathFormulaRule() {
		return getPathFormulaAccess().getRule();
	}

	//UntilFormula:
	//	left=StateFormula '\\U' bound=Bound? right=StateFormula;
	public UntilFormulaElements getUntilFormulaAccess() {
		return pUntilFormula;
	}
	
	public ParserRule getUntilFormulaRule() {
		return getUntilFormulaAccess().getRule();
	}

	//Bound:
	//	relop=Relations limit=INT;
	public BoundElements getBoundAccess() {
		return pBound;
	}
	
	public ParserRule getBoundRule() {
		return getBoundAccess().getRule();
	}

	//NextFormula:
	//	'\\X' arg=StateFormula;
	public NextFormulaElements getNextFormulaAccess() {
		return pNextFormula;
	}
	
	public ParserRule getNextFormulaRule() {
		return getNextFormulaAccess().getRule();
	}

	//StateFormula:
	//	StateOr;
	public StateFormulaElements getStateFormulaAccess() {
		return pStateFormula;
	}
	
	public ParserRule getStateFormulaRule() {
		return getStateFormulaAccess().getRule();
	}

	//StateOr StateFormula:
	//	StateAnd ({StateOr.left=current} '|' right=StateOr)?
	public StateOrElements getStateOrAccess() {
		return pStateOr;
	}
	
	public ParserRule getStateOrRule() {
		return getStateOrAccess().getRule();
	}

	//StateAnd StateFormula:
	//	BaseStateFormula ({StateAnd.left=current} '&' right=StateAnd)?
	public StateAndElements getStateAndAccess() {
		return pStateAnd;
	}
	
	public ParserRule getStateAndRule() {
		return getStateAndAccess().getRule();
	}

	//BaseStateFormula StateFormula:
	//	AtomicStateFormula
	//	| NegationFormula
	//	| '(' StateFormula ')'
	//	| ProbabilityFormula
	public BaseStateFormulaElements getBaseStateFormulaAccess() {
		return pBaseStateFormula;
	}
	
	public ParserRule getBaseStateFormulaRule() {
		return getBaseStateFormulaAccess().getRule();
	}

	//ProbabilityFormula:
	//	'\\P' relation=Relations value=NumericalValue '[' path=PathFormula ']';
	public ProbabilityFormulaElements getProbabilityFormulaAccess() {
		return pProbabilityFormula;
	}
	
	public ParserRule getProbabilityFormulaRule() {
		return getProbabilityFormulaAccess().getRule();
	}

	//NegationFormula:
	//	'!' argument=BaseStateFormula;
	public NegationFormulaElements getNegationFormulaAccess() {
		return pNegationFormula;
	}
	
	public ParserRule getNegationFormulaRule() {
		return getNegationFormulaAccess().getRule();
	}

	//AtomicStateFormula:
	//	'{' exp=Expression '}';
	public AtomicStateFormulaElements getAtomicStateFormulaAccess() {
		return pAtomicStateFormula;
	}
	
	public ParserRule getAtomicStateFormulaRule() {
		return getAtomicStateFormulaAccess().getRule();
	}

	//PrismSystem:
	//	'system'
	//	AlphabetisedParallelComposition
	//	'endsystem';
	public PrismSystemElements getPrismSystemAccess() {
		return pPrismSystem;
	}
	
	public ParserRule getPrismSystemRule() {
		return getPrismSystemAccess().getRule();
	}

	//AlphabetisedParallelComposition PrismSystem:
	//	AsynchronousParallelComposition ({AlphabetisedParallelComposition.left=current} '||'
	//	right=AlphabetisedParallelComposition)?
	public AlphabetisedParallelCompositionElements getAlphabetisedParallelCompositionAccess() {
		return pAlphabetisedParallelComposition;
	}
	
	public ParserRule getAlphabetisedParallelCompositionRule() {
		return getAlphabetisedParallelCompositionAccess().getRule();
	}

	//AsynchronousParallelComposition PrismSystem:
	//	RestrictedParallelComposition ({AsynchronousParallelComposition.left=current} '|||'
	//	right=AsynchronousParallelComposition)?
	public AsynchronousParallelCompositionElements getAsynchronousParallelCompositionAccess() {
		return pAsynchronousParallelComposition;
	}
	
	public ParserRule getAsynchronousParallelCompositionRule() {
		return getAsynchronousParallelCompositionAccess().getRule();
	}

	//RestrictedParallelComposition PrismSystem:
	//	Hiding ({RestrictedParallelComposition.left=current} '|[' (actions+=ID (',' actions+=ID)*)? '|]'
	//	right=RestrictedParallelComposition)?
	public RestrictedParallelCompositionElements getRestrictedParallelCompositionAccess() {
		return pRestrictedParallelComposition;
	}
	
	public ParserRule getRestrictedParallelCompositionRule() {
		return getRestrictedParallelCompositionAccess().getRule();
	}

	//Hiding PrismSystem:
	//	Renaming ({Hiding.argument=current} '/' '{' (actions+=ID (',' actions+=ID)*)? '}')?
	public HidingElements getHidingAccess() {
		return pHiding;
	}
	
	public ParserRule getHidingRule() {
		return getHidingAccess().getRule();
	}

	//Renaming PrismSystem:
	//	BaseModule ({Renaming.argument=current} '{' (renaming+=ActionRenaming (',' renaming+=ActionRenaming)*)? '}')?
	public RenamingElements getRenamingAccess() {
		return pRenaming;
	}
	
	public ParserRule getRenamingRule() {
		return getRenamingAccess().getRule();
	}

	//ActionRenaming:
	//	source=ID '<-' target=ID;
	public ActionRenamingElements getActionRenamingAccess() {
		return pActionRenaming;
	}
	
	public ParserRule getActionRenamingRule() {
		return getActionRenamingAccess().getRule();
	}

	//BaseModule PrismSystem:
	//	ModuleReference
	//	| '(' AlphabetisedParallelComposition ')'
	public BaseModuleElements getBaseModuleAccess() {
		return pBaseModule;
	}
	
	public ParserRule getBaseModuleRule() {
		return getBaseModuleAccess().getRule();
	}

	//ModuleReference:
	//	module=[Module];
	public ModuleReferenceElements getModuleReferenceAccess() {
		return pModuleReference;
	}
	
	public ParserRule getModuleReferenceRule() {
		return getModuleReferenceAccess().getRule();
	}

	//Global Variable:
	//	'global' Variable
	public GlobalElements getGlobalAccess() {
		return pGlobal;
	}
	
	public ParserRule getGlobalRule() {
		return getGlobalAccess().getRule();
	}

	//Label:
	//	'label' name=STRING '=' expression=Expression ';';
	public LabelElements getLabelAccess() {
		return pLabel;
	}
	
	public ParserRule getLabelRule() {
		return getLabelAccess().getRule();
	}

	//Formula:
	//	'formula' name=ID '=' expression=Expression ';';
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}

	//InitPredicate:
	//	'init'
	//	predicate=Expression
	//	'endinit';
	public InitPredicateElements getInitPredicateAccess() {
		return pInitPredicate;
	}
	
	public ParserRule getInitPredicateRule() {
		return getInitPredicateAccess().getRule();
	}

	//Reward:
	//	{Reward}
	//	'rewards' label=STRING? cases+=RewardCase* 'endrewards';
	public RewardElements getRewardAccess() {
		return pReward;
	}
	
	public ParserRule getRewardRule() {
		return getRewardAccess().getRule();
	}

	//RewardCase:
	//	('[' action=ID ']')? guard=Expression ':' value=Expression ';';
	public RewardCaseElements getRewardCaseAccess() {
		return pRewardCase;
	}
	
	public ParserRule getRewardCaseRule() {
		return getRewardCaseAccess().getRule();
	}

	//Constant:
	//	'const' type=ConstantType name=ID '=' exp=Expression ';';
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}

	//enum ConstantType:
	//	CINT='int' | CBOOL='bool' | CDOUBLE='double';
	public ConstantTypeElements getConstantTypeAccess() {
		return eConstantType;
	}
	
	public EnumRule getConstantTypeRule() {
		return getConstantTypeAccess().getRule();
	}

	//Module:
	//	'module' name=ID body=ModuleBody 'endmodule';
	public ModuleElements getModuleAccess() {
		return pModule;
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	//ModuleBody:
	//	ModuleBodyDeclaration | VariableRenaming;
	public ModuleBodyElements getModuleBodyAccess() {
		return pModuleBody;
	}
	
	public ParserRule getModuleBodyRule() {
		return getModuleBodyAccess().getRule();
	}

	//VariableRenaming:
	//	'=' module=[Module] '[' renaming+=SymbolRenaming (',' renaming+=SymbolRenaming)* ']';
	public VariableRenamingElements getVariableRenamingAccess() {
		return pVariableRenaming;
	}
	
	public ParserRule getVariableRenamingRule() {
		return getVariableRenamingAccess().getRule();
	}

	//SymbolRenaming:
	//	source=ID '=' target=ID;
	public SymbolRenamingElements getSymbolRenamingAccess() {
		return pSymbolRenaming;
	}
	
	public ParserRule getSymbolRenamingRule() {
		return getSymbolRenamingAccess().getRule();
	}

	//ModuleBodyDeclaration:
	//	{ModuleBodyDeclaration} variables+=Variable*
	//	commands+=Command*;
	public ModuleBodyDeclarationElements getModuleBodyDeclarationAccess() {
		return pModuleBodyDeclaration;
	}
	
	public ParserRule getModuleBodyDeclarationRule() {
		return getModuleBodyDeclarationAccess().getRule();
	}

	//Command:
	//	'[' act=ID? ']' guard=Expression '->' updates+=Update ('+' updates+=Update)* ';';
	public CommandElements getCommandAccess() {
		return pCommand;
	}
	
	public ParserRule getCommandRule() {
		return getCommandAccess().getRule();
	}

	//Update:
	//	(weight=Expression ':')? elements+=UpdateElement ('&' elements+=UpdateElement)*;
	public UpdateElements getUpdateAccess() {
		return pUpdate;
	}
	
	public ParserRule getUpdateRule() {
		return getUpdateAccess().getRule();
	}

	//UpdateElement:
	//	'(' variable=NEXTID '=' expression=Expression ')';
	public UpdateElementElements getUpdateElementAccess() {
		return pUpdateElement;
	}
	
	public ParserRule getUpdateElementRule() {
		return getUpdateElementAccess().getRule();
	}

	//terminal NEXTID:
	//	ID '\'';
	public TerminalRule getNEXTIDRule() {
		return tNEXTID;
	} 

	//Variable:
	//	name=ID ':' type=Type ('init' init=Expression)? ';';
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//Type:
	//	BooleanType | IntervalType;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//IntervalType:
	//	'[' min=Expression INTERVAL max=Expression ']';
	public IntervalTypeElements getIntervalTypeAccess() {
		return pIntervalType;
	}
	
	public ParserRule getIntervalTypeRule() {
		return getIntervalTypeAccess().getRule();
	}

	//BooleanType:
	//	{BooleanType}
	//	'bool';
	public BooleanTypeElements getBooleanTypeAccess() {
		return pBooleanType;
	}
	
	public ParserRule getBooleanTypeRule() {
		return getBooleanTypeAccess().getRule();
	}

	//Expression:
	//	IfThenElse;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//IfThenElse Expression:
	//	Implies ({IfThenElse.guard=current} '?' thenCase=IfThenElse ':' elseCase=Implies)*
	public IfThenElseElements getIfThenElseAccess() {
		return pIfThenElse;
	}
	
	public ParserRule getIfThenElseRule() {
		return getIfThenElseAccess().getRule();
	}

	//Implies Expression:
	//	IfAndOnlyIf ({Implies.left=current} '=>' right=IfAndOnlyIf)*
	public ImpliesElements getImpliesAccess() {
		return pImplies;
	}
	
	public ParserRule getImpliesRule() {
		return getImpliesAccess().getRule();
	}

	//IfAndOnlyIf Expression:
	//	OrExpression ({IfAndOnlyIf.left=current} '<=>' right=OrExpression)*
	public IfAndOnlyIfElements getIfAndOnlyIfAccess() {
		return pIfAndOnlyIf;
	}
	
	public ParserRule getIfAndOnlyIfRule() {
		return getIfAndOnlyIfAccess().getRule();
	}

	//OrExpression Expression:
	//	AndExpression ({OrExpression.left=current} '|' right=AndExpression)*
	public OrExpressionElements getOrExpressionAccess() {
		return pOrExpression;
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression Expression:
	//	Negation ({AndExpression.left=current} '&' right=Negation)*
	public AndExpressionElements getAndExpressionAccess() {
		return pAndExpression;
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//Negation Expression:
	//	'!' {Negation} arg=Negation | RelExpression
	public NegationElements getNegationAccess() {
		return pNegation;
	}
	
	public ParserRule getNegationRule() {
		return getNegationAccess().getRule();
	}

	//RelExpression Expression:
	//	SumExpression ({RelExpression.left=current} relop=Relations right=SumExpression)*
	public RelExpressionElements getRelExpressionAccess() {
		return pRelExpression;
	}
	
	public ParserRule getRelExpressionRule() {
		return getRelExpressionAccess().getRule();
	}

	//enum Relations:
	//	LSS='<'
	//	| LEQ='<='
	//	| EQ='='
	//	| NEQ='!='
	//	| GTR='>'
	//	| GEQ='>=';
	public RelationsElements getRelationsAccess() {
		return eRelations;
	}
	
	public EnumRule getRelationsRule() {
		return getRelationsAccess().getRule();
	}

	//SumExpression Expression:
	//	MulExpression ({SumExpression.left=current} op=('+' | '-') right=MulExpression)*
	public SumExpressionElements getSumExpressionAccess() {
		return pSumExpression;
	}
	
	public ParserRule getSumExpressionRule() {
		return getSumExpressionAccess().getRule();
	}

	//MulExpression Expression:
	//	BaseExpression ({MulExpression.left=current} op=('*' | '/') right=BaseExpression)*
	public MulExpressionElements getMulExpressionAccess() {
		return pMulExpression;
	}
	
	public ParserRule getMulExpressionRule() {
		return getMulExpressionAccess().getRule();
	}

	//BaseExpression Expression:
	//	NumericalValue
	//	| Reference
	//	| True
	//	| False
	//	| '(' Expression ')'
	//	| MinFunction
	//	| MaxFunction
	//	| PowFunction
	//	| FloorFunction
	//	| CeilFunction
	//	| ModFunction
	//	| LogFunction
	public BaseExpressionElements getBaseExpressionAccess() {
		return pBaseExpression;
	}
	
	public ParserRule getBaseExpressionRule() {
		return getBaseExpressionAccess().getRule();
	}

	//LogFunction:
	//	'log' '(' argument=Expression ',' base=Expression ')';
	public LogFunctionElements getLogFunctionAccess() {
		return pLogFunction;
	}
	
	public ParserRule getLogFunctionRule() {
		return getLogFunctionAccess().getRule();
	}

	//ModFunction:
	//	'mod' '(' dividend=Expression ',' divisor=Expression ')';
	public ModFunctionElements getModFunctionAccess() {
		return pModFunction;
	}
	
	public ParserRule getModFunctionRule() {
		return getModFunctionAccess().getRule();
	}

	//CeilFunction:
	//	'ceil' '(' arg=Expression ')';
	public CeilFunctionElements getCeilFunctionAccess() {
		return pCeilFunction;
	}
	
	public ParserRule getCeilFunctionRule() {
		return getCeilFunctionAccess().getRule();
	}

	//FloorFunction:
	//	'floor' '(' arg=Expression ')';
	public FloorFunctionElements getFloorFunctionAccess() {
		return pFloorFunction;
	}
	
	public ParserRule getFloorFunctionRule() {
		return getFloorFunctionAccess().getRule();
	}

	//PowFunction:
	//	'pow' '(' base=Expression ',' exponent=Expression ')';
	public PowFunctionElements getPowFunctionAccess() {
		return pPowFunction;
	}
	
	public ParserRule getPowFunctionRule() {
		return getPowFunctionAccess().getRule();
	}

	//MaxFunction:
	//	'max' '(' args+=Expression (',' args+=Expression)+ ')';
	public MaxFunctionElements getMaxFunctionAccess() {
		return pMaxFunction;
	}
	
	public ParserRule getMaxFunctionRule() {
		return getMaxFunctionAccess().getRule();
	}

	//MinFunction:
	//	'min' '(' args+=Expression (',' args+=Expression)+ ')';
	public MinFunctionElements getMinFunctionAccess() {
		return pMinFunction;
	}
	
	public ParserRule getMinFunctionRule() {
		return getMinFunctionAccess().getRule();
	}

	/// *
	//    log(x,b), which computes the logarithm of x to base b. 
	//    *  * / True:
	//	{True}
	//	'true';
	public TrueElements getTrueAccess() {
		return pTrue;
	}
	
	public ParserRule getTrueRule() {
		return getTrueAccess().getRule();
	}

	//False:
	//	{False}
	//	'false';
	public FalseElements getFalseAccess() {
		return pFalse;
	}
	
	public ParserRule getFalseRule() {
		return getFalseAccess().getRule();
	}

	//Reference:
	//	reference=ID;
	public ReferenceElements getReferenceAccess() {
		return pReference;
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}

	//NumericalValue Expression:
	//	DecimalLiteral
	public NumericalValueElements getNumericalValueAccess() {
		return pNumericalValue;
	}
	
	public ParserRule getNumericalValueRule() {
		return getNumericalValueAccess().getRule();
	}

	/// * 
	//ExponentialLiteral returns NumericalValue:
	//	DecimalLiteral ({ExponentialLiteral.realNumber = current} ('e'|'E') exp=INT)?
	//;
	// * / DecimalLiteral NumericalValue:
	//	IntegerLiteral ({DecimalLiteral.integerPart=current} decimalPart=DECIMAL_PART)?
	public DecimalLiteralElements getDecimalLiteralAccess() {
		return pDecimalLiteral;
	}
	
	public ParserRule getDecimalLiteralRule() {
		return getDecimalLiteralAccess().getRule();
	}

	////NumericalLiteral:
	////	integerPart=INT
	////;
	//IntegerLiteral:
	//	integerPart=INT;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return pIntegerLiteral;
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}

	//terminal DTMC:
	//	'probabilistic' | 'dtmc';
	public TerminalRule getDTMCRule() {
		return tDTMC;
	} 

	//terminal MDP:
	//	'nondeterminitic' | 'mdp';
	public TerminalRule getMDPRule() {
		return tMDP;
	} 

	//terminal CTMC:
	//	'stochastic' | 'ctmc';
	public TerminalRule getCTMCRule() {
		return tCTMC;
	} 

	//ModelType:
	//	DTMC | MDP | CTMC;
	public ModelTypeElements getModelTypeAccess() {
		return pModelType;
	}
	
	public ParserRule getModelTypeRule() {
		return getModelTypeAccess().getRule();
	}

	//terminal STRING:
	//	'"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal INTERVAL:
	//	'..';
	public TerminalRule getINTERVALRule() {
		return tINTERVAL;
	} 

	//terminal DECIMAL_PART:
	//	'.' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9')*;
	public TerminalRule getDECIMAL_PARTRule() {
		return tDECIMAL_PART;
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
