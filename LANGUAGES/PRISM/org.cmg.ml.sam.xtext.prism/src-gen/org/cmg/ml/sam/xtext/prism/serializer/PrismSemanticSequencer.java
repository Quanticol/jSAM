/*
 * generated by Xtext
 */
package org.cmg.ml.sam.xtext.prism.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.cmg.ml.sam.xtext.prism.prism.ActionRenaming;
import org.cmg.ml.sam.xtext.prism.prism.AlphabetisedParallelComposition;
import org.cmg.ml.sam.xtext.prism.prism.AndExpression;
import org.cmg.ml.sam.xtext.prism.prism.AsynchronousParallelComposition;
import org.cmg.ml.sam.xtext.prism.prism.AtomicStateFormula;
import org.cmg.ml.sam.xtext.prism.prism.BooleanType;
import org.cmg.ml.sam.xtext.prism.prism.Bound;
import org.cmg.ml.sam.xtext.prism.prism.CeilFunction;
import org.cmg.ml.sam.xtext.prism.prism.Command;
import org.cmg.ml.sam.xtext.prism.prism.Constant;
import org.cmg.ml.sam.xtext.prism.prism.DecimalLiteral;
import org.cmg.ml.sam.xtext.prism.prism.False;
import org.cmg.ml.sam.xtext.prism.prism.FloorFunction;
import org.cmg.ml.sam.xtext.prism.prism.Formula;
import org.cmg.ml.sam.xtext.prism.prism.Hiding;
import org.cmg.ml.sam.xtext.prism.prism.IfAndOnlyIf;
import org.cmg.ml.sam.xtext.prism.prism.IfThenElse;
import org.cmg.ml.sam.xtext.prism.prism.Implies;
import org.cmg.ml.sam.xtext.prism.prism.InitPredicate;
import org.cmg.ml.sam.xtext.prism.prism.IntegerLiteral;
import org.cmg.ml.sam.xtext.prism.prism.IntervalType;
import org.cmg.ml.sam.xtext.prism.prism.Label;
import org.cmg.ml.sam.xtext.prism.prism.LogFunction;
import org.cmg.ml.sam.xtext.prism.prism.MaxFunction;
import org.cmg.ml.sam.xtext.prism.prism.MinFunction;
import org.cmg.ml.sam.xtext.prism.prism.ModFunction;
import org.cmg.ml.sam.xtext.prism.prism.Model;
import org.cmg.ml.sam.xtext.prism.prism.Module;
import org.cmg.ml.sam.xtext.prism.prism.ModuleBodyDeclaration;
import org.cmg.ml.sam.xtext.prism.prism.ModuleReference;
import org.cmg.ml.sam.xtext.prism.prism.MulExpression;
import org.cmg.ml.sam.xtext.prism.prism.Negation;
import org.cmg.ml.sam.xtext.prism.prism.NegationFormula;
import org.cmg.ml.sam.xtext.prism.prism.NextFormula;
import org.cmg.ml.sam.xtext.prism.prism.OrExpression;
import org.cmg.ml.sam.xtext.prism.prism.PathFormulaDeclaration;
import org.cmg.ml.sam.xtext.prism.prism.PowFunction;
import org.cmg.ml.sam.xtext.prism.prism.PrismPackage;
import org.cmg.ml.sam.xtext.prism.prism.ProbabilityFormula;
import org.cmg.ml.sam.xtext.prism.prism.Reference;
import org.cmg.ml.sam.xtext.prism.prism.RelExpression;
import org.cmg.ml.sam.xtext.prism.prism.Renaming;
import org.cmg.ml.sam.xtext.prism.prism.RestrictedParallelComposition;
import org.cmg.ml.sam.xtext.prism.prism.Reward;
import org.cmg.ml.sam.xtext.prism.prism.RewardCase;
import org.cmg.ml.sam.xtext.prism.prism.StateAnd;
import org.cmg.ml.sam.xtext.prism.prism.StateFormulaDeclaration;
import org.cmg.ml.sam.xtext.prism.prism.StateOr;
import org.cmg.ml.sam.xtext.prism.prism.SumExpression;
import org.cmg.ml.sam.xtext.prism.prism.SymbolRenaming;
import org.cmg.ml.sam.xtext.prism.prism.True;
import org.cmg.ml.sam.xtext.prism.prism.UntilFormula;
import org.cmg.ml.sam.xtext.prism.prism.Update;
import org.cmg.ml.sam.xtext.prism.prism.UpdateElement;
import org.cmg.ml.sam.xtext.prism.prism.Variable;
import org.cmg.ml.sam.xtext.prism.prism.VariableRenaming;
import org.cmg.ml.sam.xtext.prism.services.PrismGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class PrismSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PrismGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PrismPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PrismPackage.ACTION_RENAMING:
				sequence_ActionRenaming(context, (ActionRenaming) semanticObject); 
				return; 
			case PrismPackage.ALPHABETISED_PARALLEL_COMPOSITION:
				sequence_AlphabetisedParallelComposition(context, (AlphabetisedParallelComposition) semanticObject); 
				return; 
			case PrismPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case PrismPackage.ASYNCHRONOUS_PARALLEL_COMPOSITION:
				sequence_AsynchronousParallelComposition(context, (AsynchronousParallelComposition) semanticObject); 
				return; 
			case PrismPackage.ATOMIC_STATE_FORMULA:
				sequence_AtomicStateFormula(context, (AtomicStateFormula) semanticObject); 
				return; 
			case PrismPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case PrismPackage.BOUND:
				sequence_Bound(context, (Bound) semanticObject); 
				return; 
			case PrismPackage.CEIL_FUNCTION:
				sequence_CeilFunction(context, (CeilFunction) semanticObject); 
				return; 
			case PrismPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case PrismPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case PrismPackage.DECIMAL_LITERAL:
				sequence_DecimalLiteral(context, (DecimalLiteral) semanticObject); 
				return; 
			case PrismPackage.FALSE:
				sequence_False(context, (False) semanticObject); 
				return; 
			case PrismPackage.FLOOR_FUNCTION:
				sequence_FloorFunction(context, (FloorFunction) semanticObject); 
				return; 
			case PrismPackage.FORMULA:
				sequence_Formula(context, (Formula) semanticObject); 
				return; 
			case PrismPackage.HIDING:
				sequence_Hiding(context, (Hiding) semanticObject); 
				return; 
			case PrismPackage.IF_AND_ONLY_IF:
				sequence_IfAndOnlyIf(context, (IfAndOnlyIf) semanticObject); 
				return; 
			case PrismPackage.IF_THEN_ELSE:
				sequence_IfThenElse(context, (IfThenElse) semanticObject); 
				return; 
			case PrismPackage.IMPLIES:
				sequence_Implies(context, (Implies) semanticObject); 
				return; 
			case PrismPackage.INIT_PREDICATE:
				sequence_InitPredicate(context, (InitPredicate) semanticObject); 
				return; 
			case PrismPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case PrismPackage.INTERVAL_TYPE:
				sequence_IntervalType(context, (IntervalType) semanticObject); 
				return; 
			case PrismPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case PrismPackage.LOG_FUNCTION:
				sequence_LogFunction(context, (LogFunction) semanticObject); 
				return; 
			case PrismPackage.MAX_FUNCTION:
				sequence_MaxFunction(context, (MaxFunction) semanticObject); 
				return; 
			case PrismPackage.MIN_FUNCTION:
				sequence_MinFunction(context, (MinFunction) semanticObject); 
				return; 
			case PrismPackage.MOD_FUNCTION:
				sequence_ModFunction(context, (ModFunction) semanticObject); 
				return; 
			case PrismPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case PrismPackage.MODULE:
				sequence_Module(context, (Module) semanticObject); 
				return; 
			case PrismPackage.MODULE_BODY_DECLARATION:
				sequence_ModuleBodyDeclaration(context, (ModuleBodyDeclaration) semanticObject); 
				return; 
			case PrismPackage.MODULE_REFERENCE:
				sequence_ModuleReference(context, (ModuleReference) semanticObject); 
				return; 
			case PrismPackage.MUL_EXPRESSION:
				sequence_MulExpression(context, (MulExpression) semanticObject); 
				return; 
			case PrismPackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case PrismPackage.NEGATION_FORMULA:
				sequence_NegationFormula(context, (NegationFormula) semanticObject); 
				return; 
			case PrismPackage.NEXT_FORMULA:
				sequence_NextFormula(context, (NextFormula) semanticObject); 
				return; 
			case PrismPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case PrismPackage.PATH_FORMULA_DECLARATION:
				sequence_PathFormulaDeclaration(context, (PathFormulaDeclaration) semanticObject); 
				return; 
			case PrismPackage.POW_FUNCTION:
				sequence_PowFunction(context, (PowFunction) semanticObject); 
				return; 
			case PrismPackage.PROBABILITY_FORMULA:
				sequence_ProbabilityFormula(context, (ProbabilityFormula) semanticObject); 
				return; 
			case PrismPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case PrismPackage.REL_EXPRESSION:
				sequence_RelExpression(context, (RelExpression) semanticObject); 
				return; 
			case PrismPackage.RENAMING:
				sequence_Renaming(context, (Renaming) semanticObject); 
				return; 
			case PrismPackage.RESTRICTED_PARALLEL_COMPOSITION:
				sequence_RestrictedParallelComposition(context, (RestrictedParallelComposition) semanticObject); 
				return; 
			case PrismPackage.REWARD:
				sequence_Reward(context, (Reward) semanticObject); 
				return; 
			case PrismPackage.REWARD_CASE:
				sequence_RewardCase(context, (RewardCase) semanticObject); 
				return; 
			case PrismPackage.STATE_AND:
				sequence_StateAnd(context, (StateAnd) semanticObject); 
				return; 
			case PrismPackage.STATE_FORMULA_DECLARATION:
				sequence_StateFormulaDeclaration(context, (StateFormulaDeclaration) semanticObject); 
				return; 
			case PrismPackage.STATE_OR:
				sequence_StateOr(context, (StateOr) semanticObject); 
				return; 
			case PrismPackage.SUM_EXPRESSION:
				sequence_SumExpression(context, (SumExpression) semanticObject); 
				return; 
			case PrismPackage.SYMBOL_RENAMING:
				sequence_SymbolRenaming(context, (SymbolRenaming) semanticObject); 
				return; 
			case PrismPackage.TRUE:
				sequence_True(context, (True) semanticObject); 
				return; 
			case PrismPackage.UNTIL_FORMULA:
				sequence_UntilFormula(context, (UntilFormula) semanticObject); 
				return; 
			case PrismPackage.UPDATE:
				sequence_Update(context, (Update) semanticObject); 
				return; 
			case PrismPackage.UPDATE_ELEMENT:
				sequence_UpdateElement(context, (UpdateElement) semanticObject); 
				return; 
			case PrismPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case PrismPackage.VARIABLE_RENAMING:
				sequence_VariableRenaming(context, (VariableRenaming) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActionRenaming returns ActionRenaming
	 *
	 * Constraint:
	 *     (source=ID target=ID)
	 */
	protected void sequence_ActionRenaming(ISerializationContext context, ActionRenaming semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ACTION_RENAMING__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ACTION_RENAMING__SOURCE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ACTION_RENAMING__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ACTION_RENAMING__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActionRenamingAccess().getSourceIDTerminalRuleCall_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getActionRenamingAccess().getTargetIDTerminalRuleCall_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns AlphabetisedParallelComposition
	 *     PrismSystem returns AlphabetisedParallelComposition
	 *     AlphabetisedParallelComposition returns AlphabetisedParallelComposition
	 *     AlphabetisedParallelComposition.AlphabetisedParallelComposition_1_0 returns AlphabetisedParallelComposition
	 *     AsynchronousParallelComposition returns AlphabetisedParallelComposition
	 *     AsynchronousParallelComposition.AsynchronousParallelComposition_1_0 returns AlphabetisedParallelComposition
	 *     RestrictedParallelComposition returns AlphabetisedParallelComposition
	 *     RestrictedParallelComposition.RestrictedParallelComposition_1_0 returns AlphabetisedParallelComposition
	 *     Hiding returns AlphabetisedParallelComposition
	 *     Hiding.Hiding_1_0 returns AlphabetisedParallelComposition
	 *     Renaming returns AlphabetisedParallelComposition
	 *     Renaming.Renaming_1_0 returns AlphabetisedParallelComposition
	 *     BaseModule returns AlphabetisedParallelComposition
	 *
	 * Constraint:
	 *     (left=AlphabetisedParallelComposition_AlphabetisedParallelComposition_1_0 right=AlphabetisedParallelComposition)
	 */
	protected void sequence_AlphabetisedParallelComposition(ISerializationContext context, AlphabetisedParallelComposition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ALPHABETISED_PARALLEL_COMPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ALPHABETISED_PARALLEL_COMPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ALPHABETISED_PARALLEL_COMPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ALPHABETISED_PARALLEL_COMPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlphabetisedParallelCompositionAccess().getAlphabetisedParallelCompositionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAlphabetisedParallelCompositionAccess().getRightAlphabetisedParallelCompositionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     IfThenElse returns AndExpression
	 *     IfThenElse.IfThenElse_1_0 returns AndExpression
	 *     Implies returns AndExpression
	 *     Implies.Implies_1_0 returns AndExpression
	 *     IfAndOnlyIf returns AndExpression
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     Negation returns AndExpression
	 *     RelExpression returns AndExpression
	 *     RelExpression.RelExpression_1_0 returns AndExpression
	 *     SumExpression returns AndExpression
	 *     SumExpression.SumExpression_1_0 returns AndExpression
	 *     MulExpression returns AndExpression
	 *     MulExpression.MulExpression_1_0 returns AndExpression
	 *     BaseExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=Negation)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightNegationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns AsynchronousParallelComposition
	 *     PrismSystem returns AsynchronousParallelComposition
	 *     AlphabetisedParallelComposition returns AsynchronousParallelComposition
	 *     AlphabetisedParallelComposition.AlphabetisedParallelComposition_1_0 returns AsynchronousParallelComposition
	 *     AsynchronousParallelComposition returns AsynchronousParallelComposition
	 *     AsynchronousParallelComposition.AsynchronousParallelComposition_1_0 returns AsynchronousParallelComposition
	 *     RestrictedParallelComposition returns AsynchronousParallelComposition
	 *     RestrictedParallelComposition.RestrictedParallelComposition_1_0 returns AsynchronousParallelComposition
	 *     Hiding returns AsynchronousParallelComposition
	 *     Hiding.Hiding_1_0 returns AsynchronousParallelComposition
	 *     Renaming returns AsynchronousParallelComposition
	 *     Renaming.Renaming_1_0 returns AsynchronousParallelComposition
	 *     BaseModule returns AsynchronousParallelComposition
	 *
	 * Constraint:
	 *     (left=AsynchronousParallelComposition_AsynchronousParallelComposition_1_0 right=AsynchronousParallelComposition)
	 */
	protected void sequence_AsynchronousParallelComposition(ISerializationContext context, AsynchronousParallelComposition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ASYNCHRONOUS_PARALLEL_COMPOSITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ASYNCHRONOUS_PARALLEL_COMPOSITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ASYNCHRONOUS_PARALLEL_COMPOSITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ASYNCHRONOUS_PARALLEL_COMPOSITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsynchronousParallelCompositionAccess().getAsynchronousParallelCompositionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAsynchronousParallelCompositionAccess().getRightAsynchronousParallelCompositionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateFormula returns AtomicStateFormula
	 *     StateOr returns AtomicStateFormula
	 *     StateOr.StateOr_1_0 returns AtomicStateFormula
	 *     StateAnd returns AtomicStateFormula
	 *     StateAnd.StateAnd_1_0 returns AtomicStateFormula
	 *     BaseStateFormula returns AtomicStateFormula
	 *     AtomicStateFormula returns AtomicStateFormula
	 *
	 * Constraint:
	 *     exp=Expression
	 */
	protected void sequence_AtomicStateFormula(ISerializationContext context, AtomicStateFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.ATOMIC_STATE_FORMULA__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.ATOMIC_STATE_FORMULA__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicStateFormulaAccess().getExpExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     {BooleanType}
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Bound returns Bound
	 *
	 * Constraint:
	 *     (relop=Relations limit=INT)
	 */
	protected void sequence_Bound(ISerializationContext context, Bound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.BOUND__RELOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.BOUND__RELOP));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.BOUND__LIMIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.BOUND__LIMIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundAccess().getRelopRelationsEnumRuleCall_0_0(), semanticObject.getRelop());
		feeder.accept(grammarAccess.getBoundAccess().getLimitINTTerminalRuleCall_1_0(), semanticObject.getLimit());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns CeilFunction
	 *     IfThenElse returns CeilFunction
	 *     IfThenElse.IfThenElse_1_0 returns CeilFunction
	 *     Implies returns CeilFunction
	 *     Implies.Implies_1_0 returns CeilFunction
	 *     IfAndOnlyIf returns CeilFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns CeilFunction
	 *     OrExpression returns CeilFunction
	 *     OrExpression.OrExpression_1_0 returns CeilFunction
	 *     AndExpression returns CeilFunction
	 *     AndExpression.AndExpression_1_0 returns CeilFunction
	 *     Negation returns CeilFunction
	 *     RelExpression returns CeilFunction
	 *     RelExpression.RelExpression_1_0 returns CeilFunction
	 *     SumExpression returns CeilFunction
	 *     SumExpression.SumExpression_1_0 returns CeilFunction
	 *     MulExpression returns CeilFunction
	 *     MulExpression.MulExpression_1_0 returns CeilFunction
	 *     BaseExpression returns CeilFunction
	 *     CeilFunction returns CeilFunction
	 *
	 * Constraint:
	 *     arg=Expression
	 */
	protected void sequence_CeilFunction(ISerializationContext context, CeilFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.CEIL_FUNCTION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.CEIL_FUNCTION__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCeilFunctionAccess().getArgExpressionParserRuleCall_2_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     (act=ID? guard=Expression updates+=Update updates+=Update*)
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Constant
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     (type=ConstantType name=ID exp=Expression)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.CONSTANT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.CONSTANT__TYPE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.CONSTANT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.CONSTANT__NAME));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.CONSTANT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.CONSTANT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getTypeConstantTypeEnumRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConstantAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantAccess().getExpExpressionParserRuleCall_4_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DecimalLiteral
	 *     IfThenElse returns DecimalLiteral
	 *     IfThenElse.IfThenElse_1_0 returns DecimalLiteral
	 *     Implies returns DecimalLiteral
	 *     Implies.Implies_1_0 returns DecimalLiteral
	 *     IfAndOnlyIf returns DecimalLiteral
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns DecimalLiteral
	 *     OrExpression returns DecimalLiteral
	 *     OrExpression.OrExpression_1_0 returns DecimalLiteral
	 *     AndExpression returns DecimalLiteral
	 *     AndExpression.AndExpression_1_0 returns DecimalLiteral
	 *     Negation returns DecimalLiteral
	 *     RelExpression returns DecimalLiteral
	 *     RelExpression.RelExpression_1_0 returns DecimalLiteral
	 *     SumExpression returns DecimalLiteral
	 *     SumExpression.SumExpression_1_0 returns DecimalLiteral
	 *     MulExpression returns DecimalLiteral
	 *     MulExpression.MulExpression_1_0 returns DecimalLiteral
	 *     BaseExpression returns DecimalLiteral
	 *     NumericalValue returns DecimalLiteral
	 *     DecimalLiteral returns DecimalLiteral
	 *
	 * Constraint:
	 *     (integerPart=DecimalLiteral_DecimalLiteral_1_0 decimalPart=DECIMAL_PART)
	 */
	protected void sequence_DecimalLiteral(ISerializationContext context, DecimalLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.DECIMAL_LITERAL__INTEGER_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.DECIMAL_LITERAL__INTEGER_PART));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.DECIMAL_LITERAL__DECIMAL_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.DECIMAL_LITERAL__DECIMAL_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalLiteralAccess().getDecimalLiteralIntegerPartAction_1_0(), semanticObject.getIntegerPart());
		feeder.accept(grammarAccess.getDecimalLiteralAccess().getDecimalPartDECIMAL_PARTTerminalRuleCall_1_1_0(), semanticObject.getDecimalPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns False
	 *     IfThenElse returns False
	 *     IfThenElse.IfThenElse_1_0 returns False
	 *     Implies returns False
	 *     Implies.Implies_1_0 returns False
	 *     IfAndOnlyIf returns False
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns False
	 *     OrExpression returns False
	 *     OrExpression.OrExpression_1_0 returns False
	 *     AndExpression returns False
	 *     AndExpression.AndExpression_1_0 returns False
	 *     Negation returns False
	 *     RelExpression returns False
	 *     RelExpression.RelExpression_1_0 returns False
	 *     SumExpression returns False
	 *     SumExpression.SumExpression_1_0 returns False
	 *     MulExpression returns False
	 *     MulExpression.MulExpression_1_0 returns False
	 *     BaseExpression returns False
	 *     False returns False
	 *
	 * Constraint:
	 *     {False}
	 */
	protected void sequence_False(ISerializationContext context, False semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FloorFunction
	 *     IfThenElse returns FloorFunction
	 *     IfThenElse.IfThenElse_1_0 returns FloorFunction
	 *     Implies returns FloorFunction
	 *     Implies.Implies_1_0 returns FloorFunction
	 *     IfAndOnlyIf returns FloorFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns FloorFunction
	 *     OrExpression returns FloorFunction
	 *     OrExpression.OrExpression_1_0 returns FloorFunction
	 *     AndExpression returns FloorFunction
	 *     AndExpression.AndExpression_1_0 returns FloorFunction
	 *     Negation returns FloorFunction
	 *     RelExpression returns FloorFunction
	 *     RelExpression.RelExpression_1_0 returns FloorFunction
	 *     SumExpression returns FloorFunction
	 *     SumExpression.SumExpression_1_0 returns FloorFunction
	 *     MulExpression returns FloorFunction
	 *     MulExpression.MulExpression_1_0 returns FloorFunction
	 *     BaseExpression returns FloorFunction
	 *     FloorFunction returns FloorFunction
	 *
	 * Constraint:
	 *     arg=Expression
	 */
	protected void sequence_FloorFunction(ISerializationContext context, FloorFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.FLOOR_FUNCTION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.FLOOR_FUNCTION__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloorFunctionAccess().getArgExpressionParserRuleCall_2_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Formula
	 *     Formula returns Formula
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 */
	protected void sequence_Formula(ISerializationContext context, Formula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.FORMULA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.FORMULA__NAME));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.FORMULA__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.FORMULA__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormulaAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFormulaAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Hiding
	 *     PrismSystem returns Hiding
	 *     AlphabetisedParallelComposition returns Hiding
	 *     AlphabetisedParallelComposition.AlphabetisedParallelComposition_1_0 returns Hiding
	 *     AsynchronousParallelComposition returns Hiding
	 *     AsynchronousParallelComposition.AsynchronousParallelComposition_1_0 returns Hiding
	 *     RestrictedParallelComposition returns Hiding
	 *     RestrictedParallelComposition.RestrictedParallelComposition_1_0 returns Hiding
	 *     Hiding returns Hiding
	 *     Hiding.Hiding_1_0 returns Hiding
	 *     Renaming returns Hiding
	 *     Renaming.Renaming_1_0 returns Hiding
	 *     BaseModule returns Hiding
	 *
	 * Constraint:
	 *     (argument=Hiding_Hiding_1_0 (actions+=ID actions+=ID*)?)
	 */
	protected void sequence_Hiding(ISerializationContext context, Hiding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfAndOnlyIf
	 *     IfThenElse returns IfAndOnlyIf
	 *     IfThenElse.IfThenElse_1_0 returns IfAndOnlyIf
	 *     Implies returns IfAndOnlyIf
	 *     Implies.Implies_1_0 returns IfAndOnlyIf
	 *     IfAndOnlyIf returns IfAndOnlyIf
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns IfAndOnlyIf
	 *     OrExpression returns IfAndOnlyIf
	 *     OrExpression.OrExpression_1_0 returns IfAndOnlyIf
	 *     AndExpression returns IfAndOnlyIf
	 *     AndExpression.AndExpression_1_0 returns IfAndOnlyIf
	 *     Negation returns IfAndOnlyIf
	 *     RelExpression returns IfAndOnlyIf
	 *     RelExpression.RelExpression_1_0 returns IfAndOnlyIf
	 *     SumExpression returns IfAndOnlyIf
	 *     SumExpression.SumExpression_1_0 returns IfAndOnlyIf
	 *     MulExpression returns IfAndOnlyIf
	 *     MulExpression.MulExpression_1_0 returns IfAndOnlyIf
	 *     BaseExpression returns IfAndOnlyIf
	 *
	 * Constraint:
	 *     (left=IfAndOnlyIf_IfAndOnlyIf_1_0 right=OrExpression)
	 */
	protected void sequence_IfAndOnlyIf(ISerializationContext context, IfAndOnlyIf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IF_AND_ONLY_IF__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IF_AND_ONLY_IF__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IF_AND_ONLY_IF__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IF_AND_ONLY_IF__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAndOnlyIfAccess().getIfAndOnlyIfLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getIfAndOnlyIfAccess().getRightOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfThenElse
	 *     IfThenElse returns IfThenElse
	 *     IfThenElse.IfThenElse_1_0 returns IfThenElse
	 *     Implies returns IfThenElse
	 *     Implies.Implies_1_0 returns IfThenElse
	 *     IfAndOnlyIf returns IfThenElse
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns IfThenElse
	 *     OrExpression returns IfThenElse
	 *     OrExpression.OrExpression_1_0 returns IfThenElse
	 *     AndExpression returns IfThenElse
	 *     AndExpression.AndExpression_1_0 returns IfThenElse
	 *     Negation returns IfThenElse
	 *     RelExpression returns IfThenElse
	 *     RelExpression.RelExpression_1_0 returns IfThenElse
	 *     SumExpression returns IfThenElse
	 *     SumExpression.SumExpression_1_0 returns IfThenElse
	 *     MulExpression returns IfThenElse
	 *     MulExpression.MulExpression_1_0 returns IfThenElse
	 *     BaseExpression returns IfThenElse
	 *
	 * Constraint:
	 *     (guard=IfThenElse_IfThenElse_1_0 thenCase=IfThenElse elseCase=Implies)
	 */
	protected void sequence_IfThenElse(ISerializationContext context, IfThenElse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IF_THEN_ELSE__GUARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IF_THEN_ELSE__GUARD));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IF_THEN_ELSE__THEN_CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IF_THEN_ELSE__THEN_CASE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IF_THEN_ELSE__ELSE_CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IF_THEN_ELSE__ELSE_CASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfThenElseAccess().getIfThenElseGuardAction_1_0(), semanticObject.getGuard());
		feeder.accept(grammarAccess.getIfThenElseAccess().getThenCaseIfThenElseParserRuleCall_1_2_0(), semanticObject.getThenCase());
		feeder.accept(grammarAccess.getIfThenElseAccess().getElseCaseImpliesParserRuleCall_1_4_0(), semanticObject.getElseCase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Implies
	 *     IfThenElse returns Implies
	 *     IfThenElse.IfThenElse_1_0 returns Implies
	 *     Implies returns Implies
	 *     Implies.Implies_1_0 returns Implies
	 *     IfAndOnlyIf returns Implies
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns Implies
	 *     OrExpression returns Implies
	 *     OrExpression.OrExpression_1_0 returns Implies
	 *     AndExpression returns Implies
	 *     AndExpression.AndExpression_1_0 returns Implies
	 *     Negation returns Implies
	 *     RelExpression returns Implies
	 *     RelExpression.RelExpression_1_0 returns Implies
	 *     SumExpression returns Implies
	 *     SumExpression.SumExpression_1_0 returns Implies
	 *     MulExpression returns Implies
	 *     MulExpression.MulExpression_1_0 returns Implies
	 *     BaseExpression returns Implies
	 *
	 * Constraint:
	 *     (left=Implies_Implies_1_0 right=IfAndOnlyIf)
	 */
	protected void sequence_Implies(ISerializationContext context, Implies semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IMPLIES__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IMPLIES__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.IMPLIES__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.IMPLIES__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImpliesAccess().getImpliesLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getImpliesAccess().getRightIfAndOnlyIfParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns InitPredicate
	 *     InitPredicate returns InitPredicate
	 *
	 * Constraint:
	 *     predicate=Expression
	 */
	protected void sequence_InitPredicate(ISerializationContext context, InitPredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.INIT_PREDICATE__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.INIT_PREDICATE__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitPredicateAccess().getPredicateExpressionParserRuleCall_1_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     IfThenElse returns IntegerLiteral
	 *     IfThenElse.IfThenElse_1_0 returns IntegerLiteral
	 *     Implies returns IntegerLiteral
	 *     Implies.Implies_1_0 returns IntegerLiteral
	 *     IfAndOnlyIf returns IntegerLiteral
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns IntegerLiteral
	 *     OrExpression returns IntegerLiteral
	 *     OrExpression.OrExpression_1_0 returns IntegerLiteral
	 *     AndExpression returns IntegerLiteral
	 *     AndExpression.AndExpression_1_0 returns IntegerLiteral
	 *     Negation returns IntegerLiteral
	 *     RelExpression returns IntegerLiteral
	 *     RelExpression.RelExpression_1_0 returns IntegerLiteral
	 *     SumExpression returns IntegerLiteral
	 *     SumExpression.SumExpression_1_0 returns IntegerLiteral
	 *     MulExpression returns IntegerLiteral
	 *     MulExpression.MulExpression_1_0 returns IntegerLiteral
	 *     BaseExpression returns IntegerLiteral
	 *     NumericalValue returns IntegerLiteral
	 *     DecimalLiteral returns IntegerLiteral
	 *     DecimalLiteral.DecimalLiteral_1_0 returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     integerPart=INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.INTEGER_LITERAL__INTEGER_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.INTEGER_LITERAL__INTEGER_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getIntegerPartINTTerminalRuleCall_0(), semanticObject.getIntegerPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns IntervalType
	 *     IntervalType returns IntervalType
	 *
	 * Constraint:
	 *     (min=Expression max=Expression)
	 */
	protected void sequence_IntervalType(ISerializationContext context, IntervalType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.INTERVAL_TYPE__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.INTERVAL_TYPE__MIN));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.INTERVAL_TYPE__MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.INTERVAL_TYPE__MAX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntervalTypeAccess().getMinExpressionParserRuleCall_1_0(), semanticObject.getMin());
		feeder.accept(grammarAccess.getIntervalTypeAccess().getMaxExpressionParserRuleCall_3_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Label
	 *     Label returns Label
	 *
	 * Constraint:
	 *     (name=STRING expression=Expression)
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.LABEL__NAME));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.LABEL__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.LABEL__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLabelAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LogFunction
	 *     IfThenElse returns LogFunction
	 *     IfThenElse.IfThenElse_1_0 returns LogFunction
	 *     Implies returns LogFunction
	 *     Implies.Implies_1_0 returns LogFunction
	 *     IfAndOnlyIf returns LogFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns LogFunction
	 *     OrExpression returns LogFunction
	 *     OrExpression.OrExpression_1_0 returns LogFunction
	 *     AndExpression returns LogFunction
	 *     AndExpression.AndExpression_1_0 returns LogFunction
	 *     Negation returns LogFunction
	 *     RelExpression returns LogFunction
	 *     RelExpression.RelExpression_1_0 returns LogFunction
	 *     SumExpression returns LogFunction
	 *     SumExpression.SumExpression_1_0 returns LogFunction
	 *     MulExpression returns LogFunction
	 *     MulExpression.MulExpression_1_0 returns LogFunction
	 *     BaseExpression returns LogFunction
	 *     LogFunction returns LogFunction
	 *
	 * Constraint:
	 *     (argument=Expression base=Expression)
	 */
	protected void sequence_LogFunction(ISerializationContext context, LogFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.LOG_FUNCTION__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.LOG_FUNCTION__ARGUMENT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.LOG_FUNCTION__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.LOG_FUNCTION__BASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogFunctionAccess().getArgumentExpressionParserRuleCall_2_0(), semanticObject.getArgument());
		feeder.accept(grammarAccess.getLogFunctionAccess().getBaseExpressionParserRuleCall_4_0(), semanticObject.getBase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MaxFunction
	 *     IfThenElse returns MaxFunction
	 *     IfThenElse.IfThenElse_1_0 returns MaxFunction
	 *     Implies returns MaxFunction
	 *     Implies.Implies_1_0 returns MaxFunction
	 *     IfAndOnlyIf returns MaxFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns MaxFunction
	 *     OrExpression returns MaxFunction
	 *     OrExpression.OrExpression_1_0 returns MaxFunction
	 *     AndExpression returns MaxFunction
	 *     AndExpression.AndExpression_1_0 returns MaxFunction
	 *     Negation returns MaxFunction
	 *     RelExpression returns MaxFunction
	 *     RelExpression.RelExpression_1_0 returns MaxFunction
	 *     SumExpression returns MaxFunction
	 *     SumExpression.SumExpression_1_0 returns MaxFunction
	 *     MulExpression returns MaxFunction
	 *     MulExpression.MulExpression_1_0 returns MaxFunction
	 *     BaseExpression returns MaxFunction
	 *     MaxFunction returns MaxFunction
	 *
	 * Constraint:
	 *     (args+=Expression args+=Expression+)
	 */
	protected void sequence_MaxFunction(ISerializationContext context, MaxFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinFunction
	 *     IfThenElse returns MinFunction
	 *     IfThenElse.IfThenElse_1_0 returns MinFunction
	 *     Implies returns MinFunction
	 *     Implies.Implies_1_0 returns MinFunction
	 *     IfAndOnlyIf returns MinFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns MinFunction
	 *     OrExpression returns MinFunction
	 *     OrExpression.OrExpression_1_0 returns MinFunction
	 *     AndExpression returns MinFunction
	 *     AndExpression.AndExpression_1_0 returns MinFunction
	 *     Negation returns MinFunction
	 *     RelExpression returns MinFunction
	 *     RelExpression.RelExpression_1_0 returns MinFunction
	 *     SumExpression returns MinFunction
	 *     SumExpression.SumExpression_1_0 returns MinFunction
	 *     MulExpression returns MinFunction
	 *     MulExpression.MulExpression_1_0 returns MinFunction
	 *     BaseExpression returns MinFunction
	 *     MinFunction returns MinFunction
	 *
	 * Constraint:
	 *     (args+=Expression args+=Expression+)
	 */
	protected void sequence_MinFunction(ISerializationContext context, MinFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ModFunction
	 *     IfThenElse returns ModFunction
	 *     IfThenElse.IfThenElse_1_0 returns ModFunction
	 *     Implies returns ModFunction
	 *     Implies.Implies_1_0 returns ModFunction
	 *     IfAndOnlyIf returns ModFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns ModFunction
	 *     OrExpression returns ModFunction
	 *     OrExpression.OrExpression_1_0 returns ModFunction
	 *     AndExpression returns ModFunction
	 *     AndExpression.AndExpression_1_0 returns ModFunction
	 *     Negation returns ModFunction
	 *     RelExpression returns ModFunction
	 *     RelExpression.RelExpression_1_0 returns ModFunction
	 *     SumExpression returns ModFunction
	 *     SumExpression.SumExpression_1_0 returns ModFunction
	 *     MulExpression returns ModFunction
	 *     MulExpression.MulExpression_1_0 returns ModFunction
	 *     BaseExpression returns ModFunction
	 *     ModFunction returns ModFunction
	 *
	 * Constraint:
	 *     (dividend=Expression divisor=Expression)
	 */
	protected void sequence_ModFunction(ISerializationContext context, ModFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.MOD_FUNCTION__DIVIDEND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.MOD_FUNCTION__DIVIDEND));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.MOD_FUNCTION__DIVISOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.MOD_FUNCTION__DIVISOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModFunctionAccess().getDividendExpressionParserRuleCall_2_0(), semanticObject.getDividend());
		feeder.accept(grammarAccess.getModFunctionAccess().getDivisorExpressionParserRuleCall_4_0(), semanticObject.getDivisor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (type=ModelType elements+=Element*)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleBody returns ModuleBodyDeclaration
	 *     ModuleBodyDeclaration returns ModuleBodyDeclaration
	 *
	 * Constraint:
	 *     (variables+=Variable* commands+=Command*)
	 */
	protected void sequence_ModuleBodyDeclaration(ISerializationContext context, ModuleBodyDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns ModuleReference
	 *     PrismSystem returns ModuleReference
	 *     AlphabetisedParallelComposition returns ModuleReference
	 *     AlphabetisedParallelComposition.AlphabetisedParallelComposition_1_0 returns ModuleReference
	 *     AsynchronousParallelComposition returns ModuleReference
	 *     AsynchronousParallelComposition.AsynchronousParallelComposition_1_0 returns ModuleReference
	 *     RestrictedParallelComposition returns ModuleReference
	 *     RestrictedParallelComposition.RestrictedParallelComposition_1_0 returns ModuleReference
	 *     Hiding returns ModuleReference
	 *     Hiding.Hiding_1_0 returns ModuleReference
	 *     Renaming returns ModuleReference
	 *     Renaming.Renaming_1_0 returns ModuleReference
	 *     BaseModule returns ModuleReference
	 *     ModuleReference returns ModuleReference
	 *
	 * Constraint:
	 *     module=[Module|ID]
	 */
	protected void sequence_ModuleReference(ISerializationContext context, ModuleReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.MODULE_REFERENCE__MODULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.MODULE_REFERENCE__MODULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleReferenceAccess().getModuleModuleIDTerminalRuleCall_0_1(), semanticObject.getModule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Module
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID body=ModuleBody)
	 */
	protected void sequence_Module(ISerializationContext context, Module semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.MODULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.MODULE__NAME));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.MODULE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.MODULE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModuleAccess().getBodyModuleBodyParserRuleCall_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulExpression
	 *     IfThenElse returns MulExpression
	 *     IfThenElse.IfThenElse_1_0 returns MulExpression
	 *     Implies returns MulExpression
	 *     Implies.Implies_1_0 returns MulExpression
	 *     IfAndOnlyIf returns MulExpression
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns MulExpression
	 *     OrExpression returns MulExpression
	 *     OrExpression.OrExpression_1_0 returns MulExpression
	 *     AndExpression returns MulExpression
	 *     AndExpression.AndExpression_1_0 returns MulExpression
	 *     Negation returns MulExpression
	 *     RelExpression returns MulExpression
	 *     RelExpression.RelExpression_1_0 returns MulExpression
	 *     SumExpression returns MulExpression
	 *     SumExpression.SumExpression_1_0 returns MulExpression
	 *     MulExpression returns MulExpression
	 *     MulExpression.MulExpression_1_0 returns MulExpression
	 *     BaseExpression returns MulExpression
	 *
	 * Constraint:
	 *     (left=MulExpression_MulExpression_1_0 (op='*' | op='/') right=BaseExpression)
	 */
	protected void sequence_MulExpression(ISerializationContext context, MulExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateFormula returns NegationFormula
	 *     StateOr returns NegationFormula
	 *     StateOr.StateOr_1_0 returns NegationFormula
	 *     StateAnd returns NegationFormula
	 *     StateAnd.StateAnd_1_0 returns NegationFormula
	 *     BaseStateFormula returns NegationFormula
	 *     NegationFormula returns NegationFormula
	 *
	 * Constraint:
	 *     argument=BaseStateFormula
	 */
	protected void sequence_NegationFormula(ISerializationContext context, NegationFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.NEGATION_FORMULA__ARGUMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.NEGATION_FORMULA__ARGUMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationFormulaAccess().getArgumentBaseStateFormulaParserRuleCall_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Negation
	 *     IfThenElse returns Negation
	 *     IfThenElse.IfThenElse_1_0 returns Negation
	 *     Implies returns Negation
	 *     Implies.Implies_1_0 returns Negation
	 *     IfAndOnlyIf returns Negation
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns Negation
	 *     OrExpression returns Negation
	 *     OrExpression.OrExpression_1_0 returns Negation
	 *     AndExpression returns Negation
	 *     AndExpression.AndExpression_1_0 returns Negation
	 *     Negation returns Negation
	 *     RelExpression returns Negation
	 *     RelExpression.RelExpression_1_0 returns Negation
	 *     SumExpression returns Negation
	 *     SumExpression.SumExpression_1_0 returns Negation
	 *     MulExpression returns Negation
	 *     MulExpression.MulExpression_1_0 returns Negation
	 *     BaseExpression returns Negation
	 *
	 * Constraint:
	 *     arg=Negation
	 */
	protected void sequence_Negation(ISerializationContext context, Negation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.NEGATION__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.NEGATION__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationAccess().getArgNegationParserRuleCall_0_2_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathFormula returns NextFormula
	 *     NextFormula returns NextFormula
	 *
	 * Constraint:
	 *     arg=StateFormula
	 */
	protected void sequence_NextFormula(ISerializationContext context, NextFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.NEXT_FORMULA__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.NEXT_FORMULA__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNextFormulaAccess().getArgStateFormulaParserRuleCall_1_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     IfThenElse returns OrExpression
	 *     IfThenElse.IfThenElse_1_0 returns OrExpression
	 *     Implies returns OrExpression
	 *     Implies.Implies_1_0 returns OrExpression
	 *     IfAndOnlyIf returns OrExpression
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     Negation returns OrExpression
	 *     RelExpression returns OrExpression
	 *     RelExpression.RelExpression_1_0 returns OrExpression
	 *     SumExpression returns OrExpression
	 *     SumExpression.SumExpression_1_0 returns OrExpression
	 *     MulExpression returns OrExpression
	 *     MulExpression.MulExpression_1_0 returns OrExpression
	 *     BaseExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns PathFormulaDeclaration
	 *     PathFormulaDeclaration returns PathFormulaDeclaration
	 *
	 * Constraint:
	 *     (name=ID formula=PathFormula)
	 */
	protected void sequence_PathFormulaDeclaration(ISerializationContext context, PathFormulaDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.PATH_FORMULA_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.PATH_FORMULA_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.PATH_FORMULA_DECLARATION__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.PATH_FORMULA_DECLARATION__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathFormulaDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPathFormulaDeclarationAccess().getFormulaPathFormulaParserRuleCall_3_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PowFunction
	 *     IfThenElse returns PowFunction
	 *     IfThenElse.IfThenElse_1_0 returns PowFunction
	 *     Implies returns PowFunction
	 *     Implies.Implies_1_0 returns PowFunction
	 *     IfAndOnlyIf returns PowFunction
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns PowFunction
	 *     OrExpression returns PowFunction
	 *     OrExpression.OrExpression_1_0 returns PowFunction
	 *     AndExpression returns PowFunction
	 *     AndExpression.AndExpression_1_0 returns PowFunction
	 *     Negation returns PowFunction
	 *     RelExpression returns PowFunction
	 *     RelExpression.RelExpression_1_0 returns PowFunction
	 *     SumExpression returns PowFunction
	 *     SumExpression.SumExpression_1_0 returns PowFunction
	 *     MulExpression returns PowFunction
	 *     MulExpression.MulExpression_1_0 returns PowFunction
	 *     BaseExpression returns PowFunction
	 *     PowFunction returns PowFunction
	 *
	 * Constraint:
	 *     (base=Expression exponent=Expression)
	 */
	protected void sequence_PowFunction(ISerializationContext context, PowFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.POW_FUNCTION__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.POW_FUNCTION__BASE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.POW_FUNCTION__EXPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.POW_FUNCTION__EXPONENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowFunctionAccess().getBaseExpressionParserRuleCall_2_0(), semanticObject.getBase());
		feeder.accept(grammarAccess.getPowFunctionAccess().getExponentExpressionParserRuleCall_4_0(), semanticObject.getExponent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateFormula returns ProbabilityFormula
	 *     StateOr returns ProbabilityFormula
	 *     StateOr.StateOr_1_0 returns ProbabilityFormula
	 *     StateAnd returns ProbabilityFormula
	 *     StateAnd.StateAnd_1_0 returns ProbabilityFormula
	 *     BaseStateFormula returns ProbabilityFormula
	 *     ProbabilityFormula returns ProbabilityFormula
	 *
	 * Constraint:
	 *     (relation=Relations value=NumericalValue path=PathFormula)
	 */
	protected void sequence_ProbabilityFormula(ISerializationContext context, ProbabilityFormula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.PROBABILITY_FORMULA__RELATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.PROBABILITY_FORMULA__RELATION));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.PROBABILITY_FORMULA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.PROBABILITY_FORMULA__VALUE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.PROBABILITY_FORMULA__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.PROBABILITY_FORMULA__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProbabilityFormulaAccess().getRelationRelationsEnumRuleCall_1_0(), semanticObject.getRelation());
		feeder.accept(grammarAccess.getProbabilityFormulaAccess().getValueNumericalValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getProbabilityFormulaAccess().getPathPathFormulaParserRuleCall_4_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Reference
	 *     IfThenElse returns Reference
	 *     IfThenElse.IfThenElse_1_0 returns Reference
	 *     Implies returns Reference
	 *     Implies.Implies_1_0 returns Reference
	 *     IfAndOnlyIf returns Reference
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns Reference
	 *     OrExpression returns Reference
	 *     OrExpression.OrExpression_1_0 returns Reference
	 *     AndExpression returns Reference
	 *     AndExpression.AndExpression_1_0 returns Reference
	 *     Negation returns Reference
	 *     RelExpression returns Reference
	 *     RelExpression.RelExpression_1_0 returns Reference
	 *     SumExpression returns Reference
	 *     SumExpression.SumExpression_1_0 returns Reference
	 *     MulExpression returns Reference
	 *     MulExpression.MulExpression_1_0 returns Reference
	 *     BaseExpression returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     reference=ID
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.REFERENCE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getReferenceIDTerminalRuleCall_0(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelExpression
	 *     IfThenElse returns RelExpression
	 *     IfThenElse.IfThenElse_1_0 returns RelExpression
	 *     Implies returns RelExpression
	 *     Implies.Implies_1_0 returns RelExpression
	 *     IfAndOnlyIf returns RelExpression
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns RelExpression
	 *     OrExpression returns RelExpression
	 *     OrExpression.OrExpression_1_0 returns RelExpression
	 *     AndExpression returns RelExpression
	 *     AndExpression.AndExpression_1_0 returns RelExpression
	 *     Negation returns RelExpression
	 *     RelExpression returns RelExpression
	 *     RelExpression.RelExpression_1_0 returns RelExpression
	 *     SumExpression returns RelExpression
	 *     SumExpression.SumExpression_1_0 returns RelExpression
	 *     MulExpression returns RelExpression
	 *     MulExpression.MulExpression_1_0 returns RelExpression
	 *     BaseExpression returns RelExpression
	 *
	 * Constraint:
	 *     (left=RelExpression_RelExpression_1_0 relop=Relations right=SumExpression)
	 */
	protected void sequence_RelExpression(ISerializationContext context, RelExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.REL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.REL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.REL_EXPRESSION__RELOP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.REL_EXPRESSION__RELOP));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.REL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.REL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelExpressionAccess().getRelExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelExpressionAccess().getRelopRelationsEnumRuleCall_1_1_0(), semanticObject.getRelop());
		feeder.accept(grammarAccess.getRelExpressionAccess().getRightSumExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Renaming
	 *     PrismSystem returns Renaming
	 *     AlphabetisedParallelComposition returns Renaming
	 *     AlphabetisedParallelComposition.AlphabetisedParallelComposition_1_0 returns Renaming
	 *     AsynchronousParallelComposition returns Renaming
	 *     AsynchronousParallelComposition.AsynchronousParallelComposition_1_0 returns Renaming
	 *     RestrictedParallelComposition returns Renaming
	 *     RestrictedParallelComposition.RestrictedParallelComposition_1_0 returns Renaming
	 *     Hiding returns Renaming
	 *     Hiding.Hiding_1_0 returns Renaming
	 *     Renaming returns Renaming
	 *     Renaming.Renaming_1_0 returns Renaming
	 *     BaseModule returns Renaming
	 *
	 * Constraint:
	 *     (argument=Renaming_Renaming_1_0 (renaming+=ActionRenaming renaming+=ActionRenaming*)?)
	 */
	protected void sequence_Renaming(ISerializationContext context, Renaming semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns RestrictedParallelComposition
	 *     PrismSystem returns RestrictedParallelComposition
	 *     AlphabetisedParallelComposition returns RestrictedParallelComposition
	 *     AlphabetisedParallelComposition.AlphabetisedParallelComposition_1_0 returns RestrictedParallelComposition
	 *     AsynchronousParallelComposition returns RestrictedParallelComposition
	 *     AsynchronousParallelComposition.AsynchronousParallelComposition_1_0 returns RestrictedParallelComposition
	 *     RestrictedParallelComposition returns RestrictedParallelComposition
	 *     RestrictedParallelComposition.RestrictedParallelComposition_1_0 returns RestrictedParallelComposition
	 *     Hiding returns RestrictedParallelComposition
	 *     Hiding.Hiding_1_0 returns RestrictedParallelComposition
	 *     Renaming returns RestrictedParallelComposition
	 *     Renaming.Renaming_1_0 returns RestrictedParallelComposition
	 *     BaseModule returns RestrictedParallelComposition
	 *
	 * Constraint:
	 *     (left=RestrictedParallelComposition_RestrictedParallelComposition_1_0 (actions+=ID actions+=ID*)? right=RestrictedParallelComposition)
	 */
	protected void sequence_RestrictedParallelComposition(ISerializationContext context, RestrictedParallelComposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RewardCase returns RewardCase
	 *
	 * Constraint:
	 *     (action=ID? guard=Expression value=Expression)
	 */
	protected void sequence_RewardCase(ISerializationContext context, RewardCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Reward
	 *     Reward returns Reward
	 *
	 * Constraint:
	 *     (label=STRING? cases+=RewardCase*)
	 */
	protected void sequence_Reward(ISerializationContext context, Reward semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StateFormula returns StateAnd
	 *     StateOr returns StateAnd
	 *     StateOr.StateOr_1_0 returns StateAnd
	 *     StateAnd returns StateAnd
	 *     StateAnd.StateAnd_1_0 returns StateAnd
	 *     BaseStateFormula returns StateAnd
	 *
	 * Constraint:
	 *     (left=StateAnd_StateAnd_1_0 right=StateAnd)
	 */
	protected void sequence_StateAnd(ISerializationContext context, StateAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.STATE_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.STATE_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.STATE_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.STATE_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateAndAccess().getStateAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getStateAndAccess().getRightStateAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Element returns StateFormulaDeclaration
	 *     StateFormulaDeclaration returns StateFormulaDeclaration
	 *
	 * Constraint:
	 *     (name=ID formula=StateFormula)
	 */
	protected void sequence_StateFormulaDeclaration(ISerializationContext context, StateFormulaDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.STATE_FORMULA_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.STATE_FORMULA_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.STATE_FORMULA_DECLARATION__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.STATE_FORMULA_DECLARATION__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateFormulaDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStateFormulaDeclarationAccess().getFormulaStateFormulaParserRuleCall_3_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StateFormula returns StateOr
	 *     StateOr returns StateOr
	 *     StateOr.StateOr_1_0 returns StateOr
	 *     StateAnd returns StateOr
	 *     StateAnd.StateAnd_1_0 returns StateOr
	 *     BaseStateFormula returns StateOr
	 *
	 * Constraint:
	 *     (left=StateOr_StateOr_1_0 right=StateOr)
	 */
	protected void sequence_StateOr(ISerializationContext context, StateOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.STATE_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.STATE_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.STATE_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.STATE_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateOrAccess().getStateOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getStateOrAccess().getRightStateOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SumExpression
	 *     IfThenElse returns SumExpression
	 *     IfThenElse.IfThenElse_1_0 returns SumExpression
	 *     Implies returns SumExpression
	 *     Implies.Implies_1_0 returns SumExpression
	 *     IfAndOnlyIf returns SumExpression
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns SumExpression
	 *     OrExpression returns SumExpression
	 *     OrExpression.OrExpression_1_0 returns SumExpression
	 *     AndExpression returns SumExpression
	 *     AndExpression.AndExpression_1_0 returns SumExpression
	 *     Negation returns SumExpression
	 *     RelExpression returns SumExpression
	 *     RelExpression.RelExpression_1_0 returns SumExpression
	 *     SumExpression returns SumExpression
	 *     SumExpression.SumExpression_1_0 returns SumExpression
	 *     MulExpression returns SumExpression
	 *     MulExpression.MulExpression_1_0 returns SumExpression
	 *     BaseExpression returns SumExpression
	 *
	 * Constraint:
	 *     (left=SumExpression_SumExpression_1_0 (op='+' | op='-') right=MulExpression)
	 */
	protected void sequence_SumExpression(ISerializationContext context, SumExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolRenaming returns SymbolRenaming
	 *
	 * Constraint:
	 *     (source=ID target=ID)
	 */
	protected void sequence_SymbolRenaming(ISerializationContext context, SymbolRenaming semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.SYMBOL_RENAMING__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.SYMBOL_RENAMING__SOURCE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.SYMBOL_RENAMING__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.SYMBOL_RENAMING__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolRenamingAccess().getSourceIDTerminalRuleCall_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getSymbolRenamingAccess().getTargetIDTerminalRuleCall_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns True
	 *     IfThenElse returns True
	 *     IfThenElse.IfThenElse_1_0 returns True
	 *     Implies returns True
	 *     Implies.Implies_1_0 returns True
	 *     IfAndOnlyIf returns True
	 *     IfAndOnlyIf.IfAndOnlyIf_1_0 returns True
	 *     OrExpression returns True
	 *     OrExpression.OrExpression_1_0 returns True
	 *     AndExpression returns True
	 *     AndExpression.AndExpression_1_0 returns True
	 *     Negation returns True
	 *     RelExpression returns True
	 *     RelExpression.RelExpression_1_0 returns True
	 *     SumExpression returns True
	 *     SumExpression.SumExpression_1_0 returns True
	 *     MulExpression returns True
	 *     MulExpression.MulExpression_1_0 returns True
	 *     BaseExpression returns True
	 *     True returns True
	 *
	 * Constraint:
	 *     {True}
	 */
	protected void sequence_True(ISerializationContext context, True semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PathFormula returns UntilFormula
	 *     UntilFormula returns UntilFormula
	 *
	 * Constraint:
	 *     (left=StateFormula bound=Bound? right=StateFormula)
	 */
	protected void sequence_UntilFormula(ISerializationContext context, UntilFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UpdateElement returns UpdateElement
	 *
	 * Constraint:
	 *     (variable=NEXTID expression=Expression)
	 */
	protected void sequence_UpdateElement(ISerializationContext context, UpdateElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.UPDATE_ELEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.UPDATE_ELEMENT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, PrismPackage.Literals.UPDATE_ELEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PrismPackage.Literals.UPDATE_ELEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateElementAccess().getVariableNEXTIDTerminalRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getUpdateElementAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Update returns Update
	 *
	 * Constraint:
	 *     (weight=Expression? elements+=UpdateElement elements+=UpdateElement*)
	 */
	protected void sequence_Update(ISerializationContext context, Update semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleBody returns VariableRenaming
	 *     VariableRenaming returns VariableRenaming
	 *
	 * Constraint:
	 *     (module=[Module|ID] renaming+=SymbolRenaming renaming+=SymbolRenaming*)
	 */
	protected void sequence_VariableRenaming(ISerializationContext context, VariableRenaming semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Variable
	 *     Global returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID type=Type init=Expression?)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
