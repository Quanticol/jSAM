/*
 * generated by Xtext
 */
package org.cmg.ml.sam.xtext.lprm.validation

import org.cmg.ml.sam.xtext.lprm.lprSpecification.Model

import org.cmg.ml.sam.xtext.lprm.lprSpecification.Variable

import org.eclipse.xtext.validation.Check

import static extension org.eclipse.xtext.EcoreUtil2.*
import org.eclipse.emf.ecore.EObject
import org.cmg.ml.sam.xtext.lprm.lprSpecification.LprSpecificationPackage
import static extension org.cmg.ml.sam.xtext.lprm.Util.*
import org.cmg.ml.sam.xtext.lprm.lprSpecification.NameableElement
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Activity
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Constant
import org.cmg.ml.sam.xtext.lprm.lprSpecification.MacroFunction
import org.cmg.ml.sam.xtext.lprm.lprSpecification.NameMapping
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Module
import org.cmg.ml.sam.xtext.lprm.lprSpecification.BodyRenaming
import com.google.inject.Inject
import org.cmg.ml.sam.xtext.lprm.typing.TypeProvider
import org.cmg.ml.sam.xtext.lprm.typing.LprmType
import org.eclipse.emf.ecore.EReference
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Expression
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Or
import org.cmg.ml.sam.xtext.lprm.lprSpecification.And
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Not
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Equal
import org.cmg.ml.sam.xtext.lprm.lprSpecification.NotEqual
import org.cmg.ml.sam.xtext.lprm.lprSpecification.LessOrEqual
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Less
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Greater
import org.cmg.ml.sam.xtext.lprm.lprSpecification.GreaterOrEqual
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Plus
import org.cmg.ml.sam.xtext.lprm.lprSpecification.LprSpecificationFactory
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Minus
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Modulo
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Mul
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Div
import org.cmg.ml.sam.xtext.lprm.lprSpecification.IfThenElse
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Log
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Ceil
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Floor
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Exp
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Pow
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Min
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Max
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Update
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Label

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class LprSpecificationValidator extends AbstractLprSpecificationValidator {
	
	public static val DUPLICATED_NAME = 'DUPLICATED_NAME' 
	
	public static val INCONSISTENT_VARIABLE_RENAMING = 'INCONSISTENT_VARIABLE_RENAMING'

	public static val GLOBAL_LOCAL_RENAMING = 'GLOBAL_LOCAL_RENAMING'
	
	public static val LOCAL_GLOBAL_RENAMING = 'LOCAL_GLOBAL_RENAMING'

	public static val ILLEGAL_LOCAL_VARIABLE_RENAMING = 'ILLEGAL_LOCAL_VARIABLE_RENAMING'
	
	public static val MISSING_RENAMING_OF_LOCAL_VARIABLE = 'MISSING_RENAMING_OF_LOCAL_VARIABLE'

	public static val UNRENAMED_LOCAL_VARIABLE = "UNRENAMED_LOCAL_VARIABLE"
	
	public static val WRONG_TYPE = "WRONG_TYPE"
	
	@Inject extension TypeProvider
	

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}


	@Check
	def checkDuplicateVariableDeclaration( Variable v ) {
		val duplicate = v.module.nameableElements.findFirst[ 
			it != v && it.name == v.name
		]
		if (duplicate != null) {
			error( "Duplicated definition for name '"+v.name+"'" , LprSpecificationPackage::eINSTANCE.element_Name , DUPLICATED_NAME)
		}
	}
	
	def getModule( EObject o ) {
		o.getContainerOfType(Model)
	}
	
	@Check
	def checkDeclarationRenaming( NameMapping renaming ) {
		if ( renaming.getContainerOfType(Module) != null ) { //This is a renaming occurring inside a module declaration!
			renaming.src.checkConsistentRenaming( renaming.trg )
		}
	}
	
	@Check
	def checkRenamingOfAllLocalVariablesInSourceModule( BodyRenaming renaming ) {
		var module = renaming.module
		var notRenamed = module.variables.findFirst[ v | renaming.renaming.forall[ m | m.src != v ] ]
		if (notRenamed != null) {
			error("Renaming of variable "+notRenamed.name+" is missing!",LprSpecificationPackage::eINSTANCE.bodyRenaming_Module,MISSING_RENAMING_OF_LOCAL_VARIABLE)	
		}
	}

	@Check
	def checkRenamingOfAllLocalVariablesInTargetModule( BodyRenaming renaming ) {
		var module = renaming.getContainerOfType(Module)
		var notRenamed = module.variables.findFirst[ v | renaming.renaming.forall[ m | m.trg != v ] ]
		if (notRenamed != null) {
			error("No variable is renamed in "+notRenamed.name+"!",LprSpecificationPackage::eINSTANCE.bodyRenaming_Module,UNRENAMED_LOCAL_VARIABLE)	
		}
	}
	
	@Check
	def checkRenamingOfLocalVariables( NameMapping renaming ) {
		var bodyRenaming = renaming.getContainerOfType( BodyRenaming )		
		if ( bodyRenaming != null ) { //This is a renaming occurring inside a module declaration!
			var declaredModule = bodyRenaming.getContainerOfType( Module )
			var renamedModule = bodyRenaming.module
			var containingModule = renaming.src.getContainerOfType( Module )
			if ((renamedModule != null) && (declaredModule != null ) && (containingModule != null)) {
				if (renaming.src.isLocalTo(renamedModule) && !renaming.trg.isLocalTo(declaredModule)) {
					error( "Variable "+renaming.src.name+" has to be renamed in a local variable of module "+declaredModule.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , ILLEGAL_LOCAL_VARIABLE_RENAMING )
				}
			}
		}
	}
	
	def dispatch isLocalTo( NameableElement v , Module m ) {
		false
	}
	
	def dispatch isLocalTo( Variable v , Module m ) {
		m.variables.contains(v)
	}

	def dispatch void checkConsistentRenaming( NameableElement v , NameableElement e ) {
	}

	def dispatch void checkConsistentRenaming( Variable v , NameableElement e ) {
		switch ( e ) {
			Variable: {
				if ((v.global)&&(!e.global)) {
					error( "Global variable "+v.name+" cannot be renamed in local variable "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , GLOBAL_LOCAL_RENAMING )
				} 
				if (v.type.toLprmType != e.type.toLprmType) {
					error("Type error: expected "+v.type.toLprmType+" is "+e.type.toLprmType,LprSpecificationPackage::eINSTANCE.nameMapping_Trg,WRONG_TYPE)
				}
			}
			Activity: {
				error( "Variable "+v.name+" cannot be renamed in activity "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
			Constant: {
				error( "Variable "+v.name+" cannot be renamed in constant "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
			MacroFunction: {
				error( "Variable "+v.name+" cannot be renamed in function "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
		}
	}
	
	def dispatch void checkConsistentRenaming( Constant v , NameableElement e ) {
		switch ( e ) {
			Variable: {
				error( "Constant "+v.name+" cannot be renamed in variable "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , GLOBAL_LOCAL_RENAMING )
			} 
			Activity: {
				error( "Constant "+v.name+" cannot be renamed in activity "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
			Constant: {
				if (v.type.toLprmType != e.type.toLprmType) {
					error("Type error: expected "+v.type.toLprmType+" is "+e.type.toLprmType,LprSpecificationPackage::eINSTANCE.nameMapping_Trg,WRONG_TYPE)
				}
			}
			MacroFunction: {
				error( "Constant "+v.name+" cannot be renamed in function "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
		}
	}
	
	def dispatch void checkConsistentRenaming( Activity v , NameableElement e ) {
		switch ( e ) {
			Variable: {
				error( "Activity "+v.name+" cannot be renamed in variable "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , GLOBAL_LOCAL_RENAMING )
			} 
			Constant: {
				error( "Activity "+v.name+" cannot be renamed in constant "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
			MacroFunction: {
				error( "Activity "+v.name+" cannot be renamed in function "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
		}
	}
	
	def dispatch void checkConsistentRenaming( MacroFunction v , NameableElement e ) {
		switch ( e ) {
			Variable: {
				error( "Function "+v.name+" cannot be renamed in variable "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , GLOBAL_LOCAL_RENAMING )
			} 
			Activity: {
				error( "Function "+v.name+" cannot be renamed in activity "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
			Constant: {
				error( "Function "+v.name+" cannot be renamed in constant "+e.name+"!", LprSpecificationPackage::eINSTANCE.nameMapping_Trg , INCONSISTENT_VARIABLE_RENAMING )
			}
			MacroFunction: {
				if (v.type.toLprmType != e.type.toLprmType) {
					error("Type error: expected "+v.type.toLprmType+" is "+e.type.toLprmType,LprSpecificationPackage::eINSTANCE.nameMapping_Trg,WRONG_TYPE)
				}
			}
		}
	}
	
	def private checkExpectedType( Expression e , LprmType type , EReference reference ) {
		var actualType = e.typeFor
		if ((actualType != LprmType::VOID)&&(actualType != type)) {
			error("Type error: expected "+type+" is "+actualType,reference,WRONG_TYPE)
		}
	}
	
	@Check
	def checkOrType( Or e ) {
		e.left?.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.or_Left )
		e.right?.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.or_Right )
	}

	@Check
	def checkAndType( And e ) {
		e.left?.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.and_Left )
		e.right?.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.and_Right )
	}

	@Check
	def checkNotType( Not e ) {
		e.expression?.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.not_Expression )
	}

	def private checkComparableTypes( LprmType type1 , LprmType type2 , EReference reference ) {
		if (!type2.isCompatibleWith(type1)) {
			error("Type error: values of "+type2+" cannot be compared with values of "+type1,reference,WRONG_TYPE)
		}		
	}
	
	@Check
	def checkEqualType( Equal e ) {
		(e.left?.typeFor ?: LprmType::VOID).checkComparableTypes( 
			(e.right?.typeFor ?: LprmType::VOID) , 
			LprSpecificationPackage::eINSTANCE.equal_Right	
		)
	}

	@Check
	def checkNotEqualType( NotEqual e ) {
		(e.left?.typeFor ?: LprmType::VOID).checkComparableTypes( 
			(e.right?.typeFor ?: LprmType::VOID) , 
			LprSpecificationPackage::eINSTANCE.notEqual_Right	
		)
	}
	
	@Check
	def checkLessOrEqualType( LessOrEqual e ) {
		(e.left?.typeFor ?: LprmType::VOID).checkComparableTypes( 
			(e.right?.typeFor ?: LprmType::VOID) , 
			LprSpecificationPackage::eINSTANCE.lessOrEqual_Right	
		)
	}

	@Check
	def checkLessType( Less e ) {
		(e.left?.typeFor ?: LprmType::VOID).checkComparableTypes( 
			(e.right?.typeFor ?: LprmType::VOID) , 
			LprSpecificationPackage::eINSTANCE.less_Right	
		)
	}

	@Check
	def checkGreaterType( Greater e ) {
		(e.left?.typeFor ?: LprmType::VOID).checkComparableTypes( 
			(e.right?.typeFor ?: LprmType::VOID) , 
			LprSpecificationPackage::eINSTANCE.greater_Right
		)
	}

	@Check
	def checkGreaterOrEqualType( GreaterOrEqual e ) {
		(e.left?.typeFor ?: LprmType::VOID).checkComparableTypes( 
			(e.right?.typeFor ?: LprmType::VOID) , 
			LprSpecificationPackage::eINSTANCE.greaterOrEqual_Right	
		)
	}
	
	def private checkArgumentOfArithmeticOperation( LprmType type , EReference reference ) {
		if ((type != LprmType::VOID)&&(type != LprmType::INT_TYPE)&&(type != LprmType::REAL_TYPE)) {
			error("Type error: "+type+" is not a valid type for arithmetic operations",reference,WRONG_TYPE)
		}		
	}
	
	@Check
	def checkTypesOfPlusArgument( Plus e ) {
		e.left?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.plus_Left)
		e.right?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.plus_Right)
	}

	@Check
	def checkTypesOfMinusArgument( Minus e ) {
		e.left?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.minus_Left)
		e.right?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.minus_Right)
	}

	@Check
	def checkTypesOfModuloArgument( Modulo e ) {
		e.left?.checkExpectedType( LprmType::INT_TYPE , LprSpecificationPackage::eINSTANCE.modulo_Left )
		e.right?.checkExpectedType( LprmType::INT_TYPE , LprSpecificationPackage::eINSTANCE.modulo_Right )
	}

	@Check
	def checkTypesOfMulArgument( Mul e ) {
		e.left?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.mul_Left)
		e.right?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.mul_Right)
	}

	@Check
	def checkTypesOfDivArgument( Div e ) {
		e.left?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.div_Left)
		e.right?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.div_Right)
	}

	@Check
	def checkTypesOfIfArgument( IfThenElse e ) {
		e.guard?.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.ifThenElse_Guard )
		var type1 = e.thenCase?.typeFor ?: LprmType::VOID
		var type2 = e.elseCase?.typeFor ?: LprmType::VOID 
		if (!type2.isCompatibleWith(type1)) {
			error("Type error: expected "+type1+" is "+type2,LprSpecificationPackage::eINSTANCE.ifThenElse_ElseCase,WRONG_TYPE)
		}
	}

	@Check
	def checkTypesOfLog( Log e ) {
		e.argument?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.log_Argument)
		e.base?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.log_Base)
	}	

	@Check
	def checkTypesOfCeil( Ceil e ) {
		e.argument?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.ceil_Argument)
	}	
	
	@Check
	def checkTypesOfFloor( Floor e ) {
		e.argument?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.floor_Argument)
	}	

	@Check
	def checkTypesOfExp( Exp e ) {
		e.argument?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.exp_Argument)
	}	
	
	@Check
	def checkTypesOfPow( Pow e ) {
		e.base?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.pow_Base)
		e.exponent?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.pow_Exponent)
	}	
	
	@Check
	def checkTypesOfMin( Min e ) {
		e.left?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.min_Left)		
		e.right?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.min_Right)		
	}	

	@Check
	def checkTypesOfMax( Max e ) {
		e.left?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.max_Left)		
		e.right?.typeFor?.checkArgumentOfArithmeticOperation( LprSpecificationPackage::eINSTANCE.max_Right)		
	}	
	
	@Check
	def checkCompatibleTypeInConstantDeclaration( Constant c ) {
		c.expression.checkExpectedType( c.type.toLprmType , LprSpecificationPackage::eINSTANCE.constant_Expression )
	}
	
	@Check
	def checkCompatibleTypeInMacroDeclaration( MacroFunction f ) {
		f.expression.checkExpectedType( f.type.toLprmType , LprSpecificationPackage::eINSTANCE.macroFunction_Expression )
	}
	
	@Check
	def checkAssignmentType( Update u ) {
		u.expression.checkExpectedType( u.target.type.toLprmType , LprSpecificationPackage::eINSTANCE.update_Expression )
	}
	
	@Check
	def checkLabelType( Label u ) {
		u.expression.checkExpectedType( LprmType::BOOLEAN_TYPE , LprSpecificationPackage::eINSTANCE.update_Expression )
	}
	
}
