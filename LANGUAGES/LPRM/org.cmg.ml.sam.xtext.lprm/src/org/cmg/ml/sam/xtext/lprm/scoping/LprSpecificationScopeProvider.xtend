/*
 * generated by Xtext
 */
package org.cmg.ml.sam.xtext.lprm.scoping

import org.cmg.ml.sam.xtext.lprm.lprSpecification.Constant
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Element
import org.cmg.ml.sam.xtext.lprm.lprSpecification.IntervalType
import org.cmg.ml.sam.xtext.lprm.lprSpecification.MacroFunction
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Model
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Module
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider

import static extension org.cmg.ml.sam.xtext.lprm.Util.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.cmg.ml.sam.xtext.lprm.lprSpecification.BodyRenaming
import org.cmg.ml.sam.xtext.lprm.lprSpecification.Label

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class LprSpecificationScopeProvider extends AbstractDeclarativeScopeProvider {

	def scope_Reference_reference( Constant constant , EReference r ) {
		constant.constantsDefinedBefore
	}
	
	def scope_Reference_reference( MacroFunction macro , EReference r ) {
		//FIXME: Only functions defined before 'macro' can be used!
		macro.validReferenceableElements
	}

	def scope_Reference_reference( Label label , EReference r ) {
		label.validReferenceableElements
	}

	def scope_Reference_reference( IntervalType type , EReference r ) {
		type.constantsDefinedBefore
	}

	def scope_Reference_reference( Module module , EReference r ) {
		module.validReferenceableElements
	}

	def scope_NameMapping_src( BodyRenaming body , EReference r ) {
		Scopes::scopeFor( 
			body.getContainerOfType(Model).nameableElements
		)
	}

	def scope_NameMapping_trg( BodyRenaming body , EReference r ) {
		Scopes::scopeFor( 
			body.getContainerOfType(Model).nameableElements
		)
	}	

	def scope_Update_target( Module module , EReference r ) {
		Scopes::scopeFor( 
			module.globalVariables +
			module.variables 
		)
	}

	def dispatch IScope constantsDefinedBefore( Element element ) {
		var model = element.getContainerOfType(Model)
		var elementList = model.elements
		Scopes::scopeFor( elementList.subList( 0 , elementList.indexOf(element) ).filter(Constant) )
	}
	
	def dispatch IScope constantsDefinedBefore( EObject cont ) {
		cont.eContainer.constantsDefinedBefore
	}
	
	def IScope validReferenceableElements( Element element ) {
		Scopes::scopeFor( 
			element.constants + element.macroFunctions + element.variables
		)
	}

	
}
